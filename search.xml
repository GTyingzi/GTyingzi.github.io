<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Characterizing stochastic time series with ordinal networks</title>
      <link href="/2021/060664421.html"/>
      <url>/2021/060664421.html</url>
      
        <content type="html"><![CDATA[<p>最近新读了一篇文章《Characterizing stochastic time series with ordinal networks》中译为《用序数网络表征随机时间序列》,将这篇文章涉及到的知识点做个梳理，对其中涉及到的程序图大部分做了实现<br><a href="https://download.csdn.net/download/mynameisgt/16660426">本篇文章中文翻译，程序代码块，外引用的分形工具箱（内含FBM，FGN函数）</a></p><hr><p>@[toc]</p><h2 id="（一）时间序列转网络的方法"><a href="#（一）时间序列转网络的方法" class="headerlink" title="（一）时间序列转网络的方法"></a>（一）时间序列转网络的方法</h2><p>给定一个时间序列${x_t},t=1…N$,及其序列的长度为N,我们构造一个n=N-d+1的重叠分区（其中d为嵌入尺寸）,$x_t\rightarrow w_t$,而$w_t={x_t,x_{t+1},…,x_{t+d-1}}$,在比较此时$w_t$内各个元素的大小,对其排序,不同的排序顺序对应着不同的π序数模式.<br>这里给出一个例子：假如有时间序列$x={8,1,6,4,2,3,7,0,5}$,这里给出嵌入维数d=2,那么由x映射到w.<br>$$<br>w={(8,1),(1,6),(6,4),(4,2),(2,3),(3,7),(7,0),(0,5)}<br>$$<br>对w内每个元素内的数组？？这么去理解吧,进行比较大小,那么可以转化为<br>$$<br>w’={(1,0),(0,1),(1,0),(1,0),(0,1),(0,1),(1,0),(0,1)}<br>$$<br>我们可以令(0,1)为$π_1$,(1,0)为$π_2$。这样我们就对一组时间序列转化成π序数模式.<br>上述π序数模式为:<br>$$<br>π={π_2,π_1,π_2,π_2,π_1,π_1,π_2,π_1,}<br>$$</p><p>π模式的种类取决于d，那么当d&gt;2时，我们会有几种π模式？这里我对扩展到d=3（d=4,5,…同理）做个讨论。<br>d=3时,若存在一组足够长前随机的时间序列,那么它映射到w的模式，在比较同处类元素的大小值时，映射到w’里面应该包括（0,1,2），（0,2,1），（1,0,2），（1,2,0），（2,0,1），（2,1,0）及3！=6种组织方式，分别对应这六种$π$序数模式,同理，当d=4时，有d!=24种$π$组织方式</p><p>OK,当我们给定一组时间序列，在给定嵌入维度d,我们怎么样去度量这组时间序列所蕴含的信息，常用的是香农熵<br><img src="https://img-blog.csdnimg.cn/20210413122753662.png" alt="在这里插入图片描述"><br>当然，从时间序列映射到$π$序数模式时，我们能得到$π_i\rightarrow π_j（i,j=1…,d!）$的个数，相应的，我们能得到每个$π_i\rightarrow π_j$占全部转移的概率，这时能得到一个转移概率矩阵。<br>比如从上面那个时间序列的例子，我们能得到下面这个转移概率矩阵<br><img src="https://img-blog.csdnimg.cn/20210413123230865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里面涉及到的一些知识点，我以前的一篇文章<a href="https://blog.csdn.net/mynameisgt/article/details/113379579">多元时间序列转化网络</a>也应用了这些思想<br>在我们今天的这篇文章里,提到了一个全局节点熵的度量。它的计算规则如下：<br>可先计算节点i的局部熵：<br><img src="https://img-blog.csdnimg.cn/20210413123934141.png" alt="在这里插入图片描述"><br>$p’_{i,j}$为从节点i到节点j重新归一化的概率,$O_j$是节点i输出到节点j的边（若由i-&gt;i,则此现象称为自环现象）<br>可通过计算上面例子中：</p><ul><li>$h(01)=-\frac{1}{3}log_2\frac{1}{3}-\frac{2}{3}log_2\frac{2}{3}=0.918$</li><li>$h(10)=-\frac{1}{4}log_2\frac{1}{4}-\frac{3}{4}log_2\frac{3}{4}=0.811$</li></ul><p>全局节点熵：<br><img src="https://img-blog.csdnimg.cn/20210413124205865.png" alt="在这里插入图片描述"><br>这里面$p’_i$为节点传入到节点i的概率,<br>由上面的例子可有：</p><ul><li>$H_{GN}=\frac{4}{7}h(01)+\frac{3}{7}h(10)=0.872$</li></ul><hr><p>我们发现在d&gt;=3时,$π_i\rightarrow π_j$存在一定的约束情况,d=3时,每个节点(一个节点对应一种π模式)有且仅与其他三个节点连接.我们来研究下产生这个现象的原因。</p><p>假定有$π_1=(0,1,2)$对应着$w_1=(x_1,x_2,x_3)$，此时的大小关系是$x_1&lt;x_2&lt;x_3$,现在下面一个分区$w_2=(x_2,x_3,x_4)$,我们发现$w_1,w_2$共有$x_2,x_3$那么下一刻的大小排列关系只可能是:</p><ul><li>$x_4&lt;x_2&lt;x_3或x_2&lt;x_4&lt;x_3或x_2&lt;x_3&lt;x_4$<br>分别对应着(1,2,0)或(1,2,0)或(0,1,2)三种π模式.即任意节点只可能与其他三个节点相连(包括自身)<pre><code>将思想扩展到嵌入维数d的所有可能的取值,序数网络存在连边的个数d*(d!)</code></pre></li></ul><h2 id="（二）简单时间序列的序数网络和随机序数网络"><a href="#（二）简单时间序列的序数网络和随机序数网络" class="headerlink" title="（二）简单时间序列的序数网络和随机序数网络"></a>（二）简单时间序列的序数网络和随机序数网络</h2><p>①讨论了在周期为T的序列下，嵌入维数d=T时的网络度量指标,平均度，最短加权平均距离<br>②1.研究了随机生成的时间序列的网络性质，同周期序列进行比较。2.对随机生成的序列进行规则处理，使得其中的序列变成指定情况下，Edit distance $\sigma$</p><p>论文里的图2（c）(e)<br><img src="https://img-blog.csdnimg.cn/20210413132000776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="c">%图二（c）(e)的实现clear;clcticN=1e4;     %序列长度for d=2:5    T=d;     data1 = (Periodic_seq(N,T,0,1))&#39;;   %生成周期序列        data2 = rand(N,1);                  %生成随机序列        [x1,y1] = ord_net(data1,d);         %获取周期序列的序数模式以及转移矩阵    [x2,y2] = ord_net(data2,d);         %获取随机序列的序数模式以及转移矩阵        k_1(d-1) = sum(sum(y1~=0))/length(unique(x1));    %获取周期序列的平均度,注意:此时存在节点的数量为length(unique(x1))    k_2(d-1) = sum(sum(y2~=0))/factorial(d);          %获取随机序列的平均度        avg_L_1(d-1) = net_avg_short_weight_floyd_(y1);  %获取周期序列的平均加权最短距离    avg_L_2(d-1) = net_avg_short_weight_floyd_(y2);  %获取随机序列的平均加权最短距离end%绘图区域------------------------------------------------------------------d=2:5;figure(1)plot(d,k_1,&#39;-^&#39;,d,k_2,&#39;-o&#39;);xlabel(&#39;Embedding dimension,d&#39;);ylabel(&#39;Average degree,&lt;k&gt;&#39;);legend(&#39;periodic&#39;,&#39;random&#39;);figure(3)plot(d,avg_L_1,&#39;-^&#39;,d,avg_L_2,&#39;-o&#39;);xlabel(&#39;Embedding dimension,d&#39;);ylabel(&#39;Average weighted shortest path,&lt;l&gt;&#39;);legend(&#39;periodic&#39;,&#39;random&#39;);toc%调用函数区域--------------------------------------------------------------function avg_L= net_avg_short_weight_floyd_(a)     %a: 加权邻接矩阵a(find(a==0))=inf;    %将不存在的边设定为无穷大%floyed算法最短距离及其对应的路线，D对应节点间最短的距离,Path对应路径D=a;n=size(D,1);path=zeros(n,n);  %前期初始化，存储数据for i=1:n    for j=1:n        if path(i,j)~=inf            path(i,j)=j;        end    endendfor k=1:n    for i=1:n        for j=1:n            if D(i,k)+D(k,j)&lt;D(i,j)                D(i,j) = D(i,k)+D(k,j);                path(i,j) = path(i,k);            end        end    endend%网路指标区域，计算平均加权最短路径区域%介绍：这里将节点间最短距离D抽出,D中节点到自身的距离设定为0,但认定存在到自身的边for i=1:size(D,1)    if D(i,i)~=inf      %不存在的边不做要求，只对存在的边进行设定        D(i,i) = 0;    %将到自身的权值设定为0    endendD1 = D(find(D~=inf));avg_L = sum(D1)/length(D1);endfunction x = Periodic_seq(N,T,x_min,x_max)   %N为生成的长度,T为周期,元素大小位于[x_min,x_max]x=zeros(1,N);iter=0;for i=1:N    x(i)=x_min+iter/(T-1)*(x_max-x_min);    iter=iter+1;    if iter&gt;=T        iter=iter-T;    endendendfunction [x,y]=ord_net(data,d)n=length(data);pailie=perms(1:d);       %生成排列方式n_k=size(pailie,1);      %获取排列方式的个数for i=1:n-d+1    for k=1:n_k        [~,id]=sort(data(i:i+d-1));        if id==pailie(k,:)&#39;            x(i)=k;        end    endendfac=factorial(d);y=zeros(fac,fac);for k=1:length(x)-1    for i=1:fac        for j=1:fac            if x(k)==i &amp;&amp;x(k+1)==j                y(i,j)=y(i,j)+1;            end        end    endendy=y/sum(sum(y));end</code></pre><p>在研究随机序数网络时，我们发现了一个有趣的现象，尽管所有排列在随机序列中都是等概率的，但边缘权值并非相同。实际上存在这样一个现象.一个节点到其他节点中有一条边的权值是其他边缘权值的两边,这一结果适用于从任何连续概率分布中得出的长随机数序列。这一现象，原论文中提到的解释我不是很理解，它是这样讲的：<br>假定d=3,有$w_1=(x_1,x_2,x_3)$假定是$x_1&lt;x_2&lt;x_3$，那么相应的排列是$π_1=(0,1,2)$,下一时刻的$w_2=(x_2,x_3,x_4)$,新元素$x_4$应该可以满足下面条件之一：</p><ul><li>Ⅰ:   $x_4&lt;x_1&lt;x_2&lt;x_3$</li><li>Ⅱ:   $x_1&lt;x_4&lt;x_2&lt;x_3$</li><li>Ⅲ:   $x_1&lt;x_2&lt;x_4&lt;x_3$</li><li>Ⅳ:   $x_1&lt;x_2&lt;x_3&lt;x_4$<br>此时Ⅰ 和Ⅱ同属于(1,2,0).Ⅲ属于(0,2,1),Ⅳ属于(0,1,2).故原文章说此时转移的有π模式到(1,2,0)的是到其他π模式的两倍。<pre><code>不理解之处?这些数据是随机生成的，此时x_4还和x_1排列相关？？</code></pre>本人对随机时间序列跑了d=3,4,5等诸多嵌入维数始终是存在着<strong>一个节点到其他节点中有一条边的权值是其他边缘权值的两边</strong><br>当时间序列足够长时,局部节点熵可以改写为:<br><img src="https://img-blog.csdnimg.cn/20210413133704713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>全局节点熵也可以相应改为：</li></ul><p><img src="https://img-blog.csdnimg.cn/2021041313374263.png" alt="在这里插入图片描述"><br>OK，讲到这里，这篇文章我们应该算是渐入佳境了吧๑乛◡乛๑</p><p>接下来该讨论如何去计算Edit distance $\sigma$<br>对于按比例$\eta$去替换原有随机序列的数据,令原有随机序列生成的转移概率矩阵记为A，替换后的转移概率矩阵记为B。</p><p>通过文献[29]，我找到了计算$\sigma$的方法,<br>$$<br>\sigma=sum(sum|A-B|)/2<br>$$<br>通过编程实现，得到了一个大致的曲线,虽然和原文献有点差异,但和指导老师讨论后，觉得应该是这样的.<br><img src="https://img-blog.csdnimg.cn/20210413134410663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里只做了d=2和d=3情况下N=1000的图，其余图改下参数就能顺便求出来了（图就不放上来了）。</p><pre><code class="c">clear;clcticN = 1000;Eta = 0.01:0.01:1;d = 2;iter=1;while iter&lt;1e2       %迭代100次，取均值x = normrnd(0,1,N,1);y = x;for k = 1:length(Eta)    eta = Eta(k);    p = randperm(ceil(N-eta*N)+1,1);    y((p+1):(p+ceil(eta*N))) = 1:ceil(eta*N);    [Pi_x,A] = ord_net(x,d);    [Pi_y,B] = ord_net(y,d);        Delta_k(iter,k) = sum(sum(abs(A-B)))/2;enditer = iter+1;endDelta=mean(Delta_k,1);%绘图区--------------------------------------------------------------------loglog(Eta,Delta);ylabel(&#39;Edit distance \sigma&#39;)xlabel(&#39;\eta&#39;)legend([&#39;d=&#39; num2str(d)])text(0.5,0.2,[&#39;N=&#39; num2str(N)])toc%调用函数区域---------------------------------------------------------------function [x,y]=ord_net(data,d)n=length(data);pailie=perms(1:d);       %生成排列方式n_k=size(pailie,1);      %获取排列方式的个数for i=1:n-d+1    for k=1:n_k        [~,id]=sort(data(i:i+d-1));        if id==pailie(k,:)&#39;            x(i)=k;        end    endendfac=factorial(d);y=zeros(fac,fac);for k=1:length(x)-1    for i=1:fac        for j=1:fac            if x(k)==i &amp;&amp;x(k+1)==j                y(i,j)=y(i,j)+1;            end        end    endendy=y/sum(sum(y));end</code></pre><p>其次，我们研究了随机网络中π模式缺失情况以及转移模式缺失情况，从直观判断,缺失的因素与嵌入维数和时间序列长度有关.相应的我做出了d=3,4,5情况下的π模式确实比例，以及转移模式缺失比例，此现象与论文相符合.<br><img src="https://img-blog.csdnimg.cn/20210413134819367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="c">clear;clcd_3=3;d_4=4;d_5=5;  %取3,4,5三个嵌入维度，注：维度过高，跑的次数太久了，这里就取三个嵌入维度观察性质k=3;qs_3=zeros(1,10^k/10);qs_4=zeros(1,10^k/10);qs_5=zeros(1,10^k/10);qs_pl_3=zeros(1,10^k/10);qs_pl_4=zeros(1,10^k/10);qs_pl_5=zeros(1,10^k/10);for kk=1:10for N=10:10:10^kdata=rand(1,N);%获取π模式和π模式转移矩阵[x_3,y_3]=fc(data,d_3);    %从data获取π模式，y0获取π模式转移矩阵[x_4,y_4]=fc(data,d_4);[x_5,y_5]=fc(data,d_5);i=N/10;%π序数模式的缺失比例qs_3(i)=1-length(unique(x_3))/factorial(d_3);qs_4(i)=1-length(unique(x_4))/factorial(d_4);qs_5(i)=1-length(unique(x_5))/factorial(d_5);%π转移的缺失比例qs_pl_3(i)=1-sum(sum(y_3~=0))/(d_3*factorial(d_3));qs_pl_4(i)=1-sum(sum(y_4~=0))/(d_4*factorial(d_4));qs_pl_5(i)=1-sum(sum(y_5~=0))/(d_5*factorial(d_5));endM=10:10:10^k;figure(1)title([&#39;迭代第:&#39; num2str(kk) &#39;次&#39;]);xlabel(&#39;Time series length,N&#39;);ylabel(&#39;Fraction of missing permutations&#39;);semilogx(M,qs_3,&#39;r&#39;);hold on;semilogx(M,qs_4,&#39;g&#39;);hold on;semilogx(M,qs_5,&#39;b&#39;);hold on;figure(2)title([&#39;迭代第:&#39; num2str(kk) &#39;次&#39;]);xlabel(&#39;Time series length,N&#39;);ylabel(&#39;Fraction of missing transitions&#39;);semilogx(M,qs_pl_3,&#39;r&#39;);hold on;semilogx(M,qs_pl_4,&#39;g&#39;);hold on;semilogx(M,qs_pl_5,&#39;b&#39;);hold on;end%输入时间序列以及维数，返回π模式及对应的π模式转移矩阵function [x,y]=fc(data,d)n=length(data);pailie=perms(1:d);       %生成排列方式n_k=size(pailie,1);      %获取排列方式的个数for i=1:n-d+1    for k=1:n_k        [~,id]=sort(data(i:i+d-1));        if id==pailie(k,:)            x(i)=k;        end    endendfac=factorial(d);y=zeros(fac,fac);for k=1:length(x)-1    for i=1:fac        for j=1:fac            if x(k)==i &amp;&amp;x(k+1)==j                y(i,j)=y(i,j)+1;            end        end    endendy=y/sum(sum(y));end   </code></pre><h2 id="（三）嘈杂的周期性时间序列的序数网络"><a href="#（三）嘈杂的周期性时间序列的序数网络" class="headerlink" title="（三）嘈杂的周期性时间序列的序数网络"></a>（三）嘈杂的周期性时间序列的序数网络</h2><p>文章中，取时间序列长度为N=10^4,讨论在周期序列，在d=T下，不同周期序列情况下加入信噪比(SNR)，看标准排列熵和全局节点熵对抗干扰能力的检测，原文得到,全局节点熵抗干扰能力更好.这里我画出的图有原文由较大的差异<br><img src="https://img-blog.csdnimg.cn/20210413140242581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>分别做了d=2,d=3时的图，</p><pre><code class="c">clear;clcN=10^4;T=3;d=T;x=Periodic_seq(N,T,0,1);     %锯齿形 周期序列,长度为N,周期为T,该周期内最大值为0,最小值为1i=1;for SNR=0:0.05:2   %信噪比    [SNR_noise_1,y]=add_SNR(x,SNR);   %输入时间序列以及信噪比,返回添加的噪声以及加完噪声后的序列    [xs,paili]=ord_net(y,d);            %输入：时间序列y,嵌入维度d,输出：序数模式xs,转移概率矩阵pailie    H(i) = Per_entro(xs);                   %输入序数模式，返回排列熵    H_GN(i) = Global_node_entro(paili);    %输入转移概率矩阵，返回全局节点熵    i = i+1;endH=H/log2(factorial(d));          %最大值标准化H_GN=H_GN/(log2(d+1)-2/(d+1));   %全局节点熵的标准化%绘图区域-------------------------------------------------------------------SNR=0:0.05:2;plot(SNR,H,&#39;go&#39;);hold on;plot(SNR,H_GN,&#39;r^&#39;);hold off;xlabel(&#39;Signal-to-noise ratio,SNR&#39;);ylabel(&#39;Entropy&#39;);legend(&#39;H&#39;,&#39;H_&#123;GN&#125;&#39;);text(1.5,0.8,[&#39;d=&#39; num2str(d)]);%调用函数区域--------------------------------------------------------------%标准排列熵function H = Per_entro(x)    %x是序数模式序列value=tabulate(x);value_3=value(:,3)/100;m=length(value_3);H=0;for i=1:m    if value_3(i)~=0        H=H-value_3(i)*log2(value_3(i));    endendend%全局节点熵 function H_GN = Global_node_entro(y)    %y为转移概率矩阵[m n]=size(y);p=y./sum(y,2);h=zeros(m,1);for i=1:m    for j=1:n        if y(i,j)~=0            h(i)=h(i)-p(i,j)*log2(p(i,j));        end    endendH_GN=sum(y)*h;end%SNR_noise为添加的噪声,y返回得到加完噪声后的序列function [SNR_noise,y]=add_SNR(data,SNR)  %data为原始时间序列，SNR为信躁比noise=randn(size(data));noise=noise-mean(noise);signal_power=1/length(data)*sum(data.*data);noise_variance=signal_power/(10^(SNR/10));SNR_noise=sqrt(noise_variance)/std(noise)*noise;y=data+SNR_noise;end%输入时间序列以及维数，返回π模式及对应的π模式转移矩阵function [x,y]=ord_net(data,d)n=length(data);pailie=perms(1:d);       %生成排列方式n_k=size(pailie,1);      %获取排列方式的个数for i=1:n-d+1    for k=1:n_k        [~,id]=sort(data(i:i+d-1));        if id==pailie(k,:)            x(i)=k;        end    endendfac=factorial(d);y=zeros(fac,fac);for k=1:length(x)-1    for i=1:fac        for j=1:fac            if x(k)==i &amp;&amp;x(k+1)==j                y(i,j)=y(i,j)+1;            end        end    endendy=y/sum(sum(y));end  function x = Periodic_seq(N,T,x_min,x_max)   %N为生成的长度,d为周期,元素大小位于[x_min,x_max]x=zeros(1,N);iter=0;for i=1:N    x(i)=x_min+iter/(T-1)*(x_max-x_min);    iter=iter+1;    if iter&gt;=T        iter=iter-T;    endendend</code></pre><h2 id="（四）分形高斯噪声（FGN）和分形布朗运动（FBM）的序数网络"><a href="#（四）分形高斯噪声（FGN）和分形布朗运动（FBM）的序数网络" class="headerlink" title="（四）分形高斯噪声（FGN）和分形布朗运动（FBM）的序数网络"></a>（四）分形高斯噪声（FGN）和分形布朗运动（FBM）的序数网络</h2><p>由给定的一个Hurst指数去生成分形布朗运动的时间序列，对其做差分及得到分形高斯噪声.<br>怎么去生成分形布朗运动的时间序列，我找到了生成这个序列的函数,具体想要的话点击这里<a href="https://download.csdn.net/download/mynameisgt/16641209">分形工具箱</a></p><p>这里讨论对于给定的Gini系数<br><img src="https://img-blog.csdnimg.cn/20210413142723277.png" alt="在这里插入图片描述"><br>这里的y对应着存在边的权值，在不同的Hurst值下，得到Gini值<br><img src="https://img-blog.csdnimg.cn/2021041314320354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里达到了论文中的效果，对于分形高斯噪声,当h≈0.5时，基尼系数会降低，且会进入一个平稳期</p><p>对于文章中的e图，我却得到不同的图，这里附上</p><p>``<img src="https://img-blog.csdnimg.cn/20210413143544843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="c">clear;clctic%获取分形高斯噪声(fgn),分数布朗运动(fbm)，代码耗时 77.189066 秒。addpath(genpath(&#39;G:\R2019b\bin\FracLab2.04\分形分析工具箱 - FracLab2.04\Programs&#39;));N = 1024;iter=1;while iter&lt;1e2    for i=1:9        H=i*0.1;        t = linspace(0,1,N) ;        fbm = fBmWoodChan(N,H) ;        fgn = diff(fbm);                %对时间序列进行处理        d=3;  %输入嵌入维数                [x1,y1]=ord_net(fgn,d);        [x2,y2]=ord_net(fbm,d);                H_Per_k(iter,i) = Per_entro(x2);        H_GN_k(iter,i) = Global_node_entro(y2);        Gini_1_k(iter,i) = Gini_total(y1);        Gini_2_k(iter,i) = Gini_total(y2);    end    iter=iter+1;endH_Per = mean(H_Per_k,1);H_Per = H_Per/log2(factorial(d));H_GN = mean(H_GN_k,1);Gini_1 = mean(Gini_1_k,1);Gini_2 = mean(Gini_2_k,1);H=0.1:0.1:0.9;%画图区域-------------------------------------------------------------------figure(1)plot(H,Gini_1,&#39;-o&#39;,H,Gini_2,&#39;-^&#39;);xlabel(&#39;Hurst exponent,h&#39;);ylabel(&#39;Gini index of edge weights&#39;);legend(&#39;fGn&#39;,&#39;fBm&#39;)figure(2)plot(H,H_Per,&#39;-^&#39;,H,H_GN,&#39;-o&#39;);hold on;xlabel(&#39;Hurst exponent,h&#39;);ylabel(&#39;Entropy&#39;);legend(&#39;H&#39;,&#39;H_&#123;GN&#125;&#39;)toc%调用函数区域-----------------------------------------------------------------%计算Gini系数function Gini = Gini_total(A)A = A(find(A~=0));n=length(A);A_bar=mean(A);s=0;for i=1:n    for j=1:n        s = s+abs(A(i)-A(j));    endendGini = s/(2*A_bar*n^2);end%标准排列熵function H = Per_entro(x)    %x是序数模式序列value=tabulate(x);value_3=value(:,3)/100;m=length(value_3);H=0;for i=1:m    if value_3(i)~=0        H=H-value_3(i)*log2(value_3(i));    endendend%全局节点熵 function H_GN = Global_node_entro(y)    %y为转移概率矩阵[m n]=size(y);p=y./sum(y,2);h=zeros(m,1);for i=1:m    for j=1:n        if y(i,j)~=0            h(i)=h(i)-p(i,j)*log2(p(i,j));        end    endendH_GN=sum(y)*h;endfunction [x,y]=ord_net(data,d)n=length(data);pailie=perms(1:d);       %生成排列方式n_k=size(pailie,1);      %获取排列方式的个数for i=1:n-d+1    for k=1:n_k        [~,id]=sort(data(i:i+d-1));        if id==pailie(k,:)&#39;            x(i)=k;        end    endendfac=factorial(d);y=zeros(fac,fac);for k=1:length(x)-1    for i=1:fac        for j=1:fac            if x(k)==i &amp;&amp;x(k+1)==j                y(i,j)=y(i,j)+1;            end        end    endendy=y/sum(sum(y));end</code></pre><p>这里有待思考，出现问题的原因可能是以下两个方面：</p><ul><li>加权最短距离算法写错了（但是，在计算图2（e）时却吻合，但我始终对这个加权最短距离保持怀疑）</li><li>生成的分形布朗运动序列与文章中的存在差异。毕竟我也不知道原文章用的那个分形布朗运动时间序列。但存在共有的Gini系数现象</li></ul><hr><p>另外对于FGN的问题上</p><ul><li>生成FGN时间序列时，因为函数生成存在误差，在信噪比为0时，应是无添加,但我们程序还是会生成噪声</li><li>信噪比不为0时，全局节点熵和排列熵并没有达到论文里的现象,这里的算法实现不难，我是很疑惑的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 复杂网络研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信噪比，基尼指数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂网络——多元时间序列转化网络</title>
      <link href="/2021/060659375.html"/>
      <url>/2021/060659375.html</url>
      
        <content type="html"><![CDATA[<p>已经学习了一段时间有关复杂网络方面的资料。接下来想记录下自己一些心得体会。OK，let’go!</p><hr><p>谈到复杂网络，首先不得避免谈到汪小凡的著作《2006_复杂网络理论及其应用 - 汪小帆》，这时一篇入门的为数不多的中文著作。这里给附上资源：<br>链接：<a href="https://pan.baidu.com/s/1p2VDdAgV29xgbqaenUBQ4A">https://pan.baidu.com/s/1p2VDdAgV29xgbqaenUBQ4A</a><br>提取码：2ass </p><p>OK，来简单讲述下自己最近所浏览的一篇论文《constructing ordinal partition transition networks from multivariate time series》中译为《从多元时间序列构造有序划分转换网络》<br>中英文PDF版资源如下：<br>链接：<a href="https://pan.baidu.com/s/1in4q7KQIhsUkUCwWzm3cGw">https://pan.baidu.com/s/1in4q7KQIhsUkUCwWzm3cGw</a><br>提取码：ecqi </p><hr><pre><code>接下来，让我们对照中文版的谈谈一些体会，在相应位置，有自己编写好的算法供大家参考</code></pre><p>page one</p><p><strong>已经提出了越来越多的算法来将标量时间序列映射到顺序分区转换网络中。 但是，经验科学中大多数可观察到的现象具有多元性质。 我们构建多元时间序列的序数分区转换网络。</strong><br><strong>这种方法产生了加权有向网络，该网络代表了速度空间中时间序列的模式转换特性，因此可以动态地了解下层系统。 此外，我们提出了一种熵的度量来表征有序分区过渡动力学，它对捕获相空间轨迹的可能局部几何变化很敏感。 我们证明了模式转换网络可用于捕获非相干转换的相位相干性，并表征相同步的路径。 因此，我们得出结论，有序分区过渡网络方法为非线性多元时间序列的传统符号分析提供了补充的见解</strong>。</p><p>​        非线性时间序列分析和复杂网络理论被广泛认为是与非线性动力学和统计物理学紧密联系的复杂系统科学领域。 越来越多的文献旨在利用复杂的网络方法来表征基于时间序列的动态系统。 有多种方法可以将给定的时间序列转换为网络表示形式，然后进行网络分析。 这里我们举几个典型的例子。 递归网络方法比较了相空间中时间点的接近性，这些时间点已应用于气候数据分析 **[1、2]**，混沌电化学振荡器 **[3]**，分数布朗运动4和油水两相过渡流动行为 **[5-7]**。<br>在音乐数据 <strong>[8]</strong> 中已经识别出一些基本的网络主题结构，其特征还在于修订的递归方法 **[9]**。 已经提出了一系列可见度图算法及其变体 **[10-12]**，以通过计算两个采样点的每对之间的所谓线性可见度条件来转换给定的时间序列，这些条件已成功应用于美国的飓风数据 <strong>[13]</strong>  ，金融市场 **[14]**，黑子时间序列 **[15、16]**，相关随机 <strong>[17]</strong> 和多重分形随机过程 **[18]**，从复杂的系统角度提供了新颖的见解。 参考文献 <strong>[18、19和20]</strong> 中讨论了其他几种方法。例如，提出了循环网络的概念，用于将时间序列映射到网络 **[21]**。表征图案的顺序有助于区分高维混沌和低维混沌 **[22]**。此外，可以通过将时间序列的各段映射到可见性图并将连续状态链接到状态网络 <strong>[23、24]</strong> 来监视时间序列的演化行为。</p><p>​        最近，越来越多的工作通过时间序列的有序划分将时间序列转换为网络 **[25、26]**。在不规则采样的时间序列中进行了一系列有序方法的系统研究 <strong>[27-29]</strong> ，这显示了研究 来自气候科学的实验观测数据 <strong>[30]</strong> 。 在这种方法中，第一步是通过使用传统时延嵌入技术将一维时间序列嵌入相空间。 相空间中的十个嵌入式点被映射到网络空间中的节点，并且基于轨迹上的时间顺序在节点之间分配链接。 结果网络是相空间中时间序列的马尔可夫链表示。 网络分析的有趣之处在于，相当简单的网络测度（甚至包括平均度）也可以跟踪与最大Lyapunov指数相当的动态转变 <strong>[25]</strong> 。</p><hr><p>page two</p><p>​        序数分区网络方法的基本思想可以追溯到识别时间序列 <strong>[31、32]</strong> 的序数模式。考虑一维时间序列{x（t）} t = 1，…，L包含来自a的L个点 动力学系统中，原始相空间可以通过时延嵌入x（t）= [x（t），x（t + τ），…，x（t +（Dx-1）τ）]来重建 Dx <strong>[33，34]</strong> .下一步是基于相对振幅计算x（t），x（t + τ），…，x（t +（Dx-1）τ）的等级顺序，方便地用 一个符号πx（t）。 当在嵌入空间中将窗口从t = 1滑动到N = L-（Dx-1）T时，会生成轨迹πx（t）的符号表示。 一种遵循符号表示法的传统方法是，基于阶数模式的频率图来计算置换熵，从而在非线性时间序列分析中产生非常完善的统计量 <strong>[31]</strong> 。 在最近的几十年中，时间序列的序数符号表示已在科学和工程中发现了许多有趣的应用，例如，生物医学记录 <strong>[35]</strong> ，金融 <strong>[36]</strong> ，气候科学 <strong>[37]</strong> 。 参考文献中对近期的一些进展进行了全面的回顾。  <strong>[35]</strong>.但是，序数模式之间的过渡行为在很大程度上仍然不清楚。 最近的序数分区网络表示法捕获了序数模式的演化行为 <strong>[25、26]</strong> ，这为时间序列的标准序数符号分析提供了新颖的见解。</p><p>​        对于给定的嵌入尺寸Dx，总共有Dx！ 可能会在时间序列中出现的唯一序数模式，而忽略了相等性。 平稳增量的随机过程满足P（xt = x.t + τ）= 0，因此具有联系xt = x.t + τ的概率为零。 对于经验时间序列，我们可以通过添加连续分布的微小白噪声来避免联系 <strong>[38]</strong> 。 因此，原始相空间将分解为Dx！ 等效分区 <strong>[31]</strong> 。 所有Dx都很直观！ 在N→∞的随机过程所产生的时间序列中，模式几乎以相等的频率出现。 但是，在确定性动力学产生的时间序列中，可能永远不会出现一组模式。 因此，可以通过对禁止模式进行计数来量化时间序列数据中的确定性。 然而，复杂性在实时分析中出现。 例如，缺失的序数模式可能与观察期间的有限时间长度以及相关的随机过程有关，这要求在相对较短的嘈杂数据中使用某些修订的方法来确定性的检测 <strong>[39-43]</strong> 。 从常规分区网络的角度来看，顺序模式的频率和不同模式之间的过渡都是不均匀的。 因此，如此获得的网络特性对不同的系统动力学很敏感，这可以成功地根据EEG数据 <strong>[25、26]</strong> 来表征健康与患者之间的差异。</p><p>​        最近的大多数工作都只关注单变量时间序列{x（t）}。 嵌入维数Dx和时间延迟T是构建有序分区网络的两个重要参数，尤其是对禁止顺序模式的出现具有关键影响 <strong>[27-29]</strong> 。 但是，对多元时间序列的泛化仍大体未触及 <strong>[5，44]</strong> 。经验科学中的大多数可观察到的现象都是多元性质的。 例如，同时观察股票市场中的资产，并分析其共同发展以更好地了解趋势。 在气候科学中，多种观测（温度，压力，降水，人类活动等，来自不同位置）是对未来气候状况进行可靠预测的基础。 我们建议从多元数据构建有序分区转换网络。</p><p><strong>Results</strong><br><img src="https://img-blog.csdnimg.cn/20210129162825766.png" alt="在这里插入图片描述"></p><p><strong><u>顺序模式定义<u></strong>  给定由确定性动态系统生成的标量时间序列{x（t）}，时间序列的顺序结构取决于嵌入维Dx和时间延迟τ **[33、34]**。<br>让我们从Dx = 2开始。 忽略相等，我们在x（t）和x（t +τ）之间有两个关系，即代表顺序模式πx的两个符号序列：<br><img src="https://img-blog.csdnimg.cn/20210129131845629.jpg#pic_center" alt="在这里插入图片描述"></p><p>对于具有连续分布值的动力系统，我们可以忽略相等性，因为Lebesgue对关系的测度为零 <strong>[31]</strong> 。 此外，大量的数值模拟表明结果不会发生质的变化，并且我们对x（t）&lt;x（t +τ）或x（t）≤x（t +τ）**[38.45]** 进行计数都无关紧要,在实际应用中，我们可以轻松测试&lt;和≤。 在此之前，我们按照参考文献中的建议执行例程。  **[45]**，不要单独考虑平等。 在这项工作中，时间延迟τ被选为1。 通过这种选择，顺序模式πx1分别捕获上升趋势，而πx0对应于时间序列的下降趋势。  定义等效于通过原始序列的一阶差分来考虑增量Δx（t）= x（t + 1）-x（t）的符号。 换句话说，相关的顺序模式捕获x（t）在其速度空间中的变化，从而直接基于位移显示动态信息而非静态信息</p><p>​        当将上述思想推广到二维时间序列（x（t），y（t））时，我们将讨论局限于将Dx = Dy = 2嵌入到单个变量中。 因此，根据递增符号（Δx（t），Δy（t））（表<strong>1</strong>），我们有四种不同的顺序模式组合：在（x（t），y（t））的相空间中，我们 具有阶式Π（t）∈（π1，π2，π3，π4）捕获了递增或递减的行为。 图 <strong>1（a，c）</strong> 的示例显示了二维序列（x（t），y（t））的有序模式的构造。 完全类推，基于增量（Δx（t），Δy（t），Δz（t）），序数模式TT（t）属于（Π1，…，Πi）i = 1，…，8 表 <strong>[2]</strong> 列举了三维时间序列（x（t），y（t），z（t））的坐标，并在图<strong>1（b，d）</strong>中将其可视化。 因此，n维时间序列（{x1}（t），…，{xn}（t））的阶模Π（t）的维数为D = 2 ^ n，因为每个分量要么增加要么降低在时间t下降趋势。</p><hr><p>page three</p><p><img src="https://img-blog.csdnimg.cn/20210129131953764.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>图1.（a）二维序列（x（t），y（t））和（c）增量序列（Δx（t），Δy（t））的阶序模式定义。  （b）树的维数级数（x（t），y（t），z（t））和（d）相应的增量级数（Δx（t），Δy（t），Δy（t））。  （c，d）分别表示增量级数和序号的符号</p><hr><p>提供代码如下：</p><pre><code class="bash">%% 二维时间序列模式clear;clc%初始数据n=10;                   %%时间序列长度为10m=20;                   %%大小设定为20之内x=m*rand(1,n);          %%随机生成长度为10的x的时间序列，大小在0~20y=m*rand(1,n);          %%随机生成长度为10的y的时间序列，大小在0~20delta_x=diff(x);        %%求x的差分，此时周期为1delta_y=diff(y);        %%求y的差分，此时周期为1m=length(delta_x);      %%获得差分长度%--------------------------------------------------------------------------%记录π序数pai_xushu=cell(1,m);for i=1:m            %%得到m个π序数    if delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π1&#39;;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π2&#39;;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π3&#39;;    else        pai_xushu&#123;i&#125;=&#39;π4&#39;;    endend%绘图区i=1:n;      %%画生成x,y图对应需要j=1:n-1;    %%画差分增量模式图需要figure(1);subplot(2,1,1);plot(i,x,&#39;o-&#39;);hold on;plot(i,y,&#39;b*-&#39;);hold off;ylabel(&#39;x,y&#39;);h1=legend(&#39;x&#39;,&#39;y&#39;);                  %%设置图例set(h1,&#39;Orientation&#39;,&#39;horizon&#39;);     set(h1,&#39;Box&#39;,&#39;off&#39;);subplot(2,1,2);plot(j,delta_x,&#39;o-&#39;);hold on;plot(j,delta_y,&#39;b*-&#39;);hold off;line([0,n],[0,0],&#39;linestyle&#39;,&#39;--&#39;);   %%添加横坐标0-n，纵坐标0-0的虚线for i=1:n-1    text(i,0,pai_xushu(i));           %%显示对应结果的π模式endxlabel(&#39;t&#39;);ylabel(&#39;Δx,Δy&#39;);h2=legend(&#39;Δx&#39;,&#39;Δy&#39;);               %%设置图例set(h2,&#39;Orientation&#39;,&#39;horizon&#39;);set(h2,&#39;Box&#39;,&#39;off&#39;);%%  三维时间序列clear;clc%初始数据n=10;             %%时间序列长度为10m=20;             %%大小设定为20之内x=m*rand(1,n);    %%随机生成长度为10的x的时间序列，大小在0~20y=m*rand(1,n);    %%随机生成长度为10的y的时间序列，大小在0~20z=m*rand(1,n);    %%随机生成长度为10的z的时间序列，大小在0~20delta_x=diff(x);  %%求x的差分delta_y=diff(y);  %%求y的差分delta_z=diff(z);  %%求z的差分m=length(delta_x);%记录π序数pai_xushu=cell(1,m);for i=1:m                    %%得到n-1个π序数    if delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π1&#39;;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π2&#39;;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π3&#39;;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π4&#39;;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π5&#39;;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π6&#39;;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π7&#39;;    else        pai_xushu&#123;i&#125;=&#39;π8&#39;;    endend%绘图区i=1:n;          %%画生成x,y图对应需要j=1:n-1;        %%画差分增量模式图需要figure(1);subplot(2,1,1);plot(i,x,&#39;o-&#39;);hold on;plot(i,y,&#39;b*-&#39;);hold on;plot(i,z,&#39;m^-&#39;);hold off;ylabel(&#39;x,y,z&#39;);h1=legend(&#39;x&#39;,&#39;y&#39;,&#39;z&#39;);        %%设置图例set(h1,&#39;Orientation&#39;,&#39;horizon&#39;);set(h1,&#39;Box&#39;,&#39;off&#39;);subplot(2,1,2);plot(j,delta_x,&#39;o-&#39;);hold on;plot(j,delta_y,&#39;b*-&#39;);hold on;plot(j,delta_z,&#39;m^-&#39;);hold off;line([0,n],[0,0],&#39;linestyle&#39;,&#39;--&#39;);   %%添加横坐标0-n，纵坐标0-0的虚线for i=1:n-1    text(i,0,pai_xushu(i));           %%显示对应结果的π模式endxlabel(&#39;t&#39;);ylabel(&#39;Δx,Δy,Δz&#39;);h2=legend(&#39;Δx&#39;,&#39;Δy&#39;,&#39;Δz&#39;);         %%设置图例set(h2,&#39;Orientation&#39;,&#39;horizon&#39;);set(h2,&#39;Box&#39;,&#39;off&#39;)</code></pre><p>运行结果为：<br><img src="https://img-blog.csdnimg.cn/20210129163902782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为我是随机生成的时间序列，所以图片会有差异，但已基本实现要求</p><hr><p><img src="https://img-blog.csdnimg.cn/20210129132027259.jpg#pic_center" alt="在这里插入图片描述"></p><p>​        注意，在这项工作中，我们没有应用时间延迟嵌入技术来从一个单变量时间序列获得多维相空间。 相反，在给定多元时间序列的情况下，我们考虑在多重测量空间中每个测量的两个连续时间点之间的增量。 换句话说，我们的方法在与其相关的速度空间（差异空间）中捕获了多元时间序列的动态特性。 因此，顺序模式定义（公式 <strong>（1）</strong> ）中的时间延迟τ与嵌入中经常使用的时间延迟具有不同的解释。 传统上，一个适当地选一个嵌入丁维和时间延迟来重建相空间从一个给定的单变量的时间序列。 我们当然可以将讨论推广到以下情况：时间延迟大于1（即τ&gt; 1），并且对于每个变量（度量）都嵌入维度Dx&gt; 2，但是我们认为对于多变量而言，动力学方面的物理意义变得模棱两可 时间序列。</p><p><strong><u>顺序分区转换网络。</u></strong> 给定一个多元时间序列，例如（x（t），y（t））的二维情况，我们将第i个模式πi的频率表示为p（πi） 时间间隔t = 1，…，N。 一个重要的特性是确定性过程中的序数模式具有不同的频率p（πi）。 然后引入置换熵HO来表征序数模式的不均匀外观，如下所示<br><img src="https://img-blog.csdnimg.cn/20210129132054830.jpg#pic_center" alt="在这里插入图片描述"></p><p>其中总和遍历所有D = 2 ^ n个排列。 我们使用log2，因此HO的单位是位。 对于一个n维独立的相同分布式随机过程，由于每个D = 2 ^ n序数模式都具有相同的频率，因此可以获得最大的熵HO = n。</p><p>​        我们通过使用图2中的三维相同的独立周期序列的玩具模型来说明上述算法.3D周期序列的周期的不同组合会产生置换熵HO的不同值。 此外，广泛观察到有限数量的可能的序数模式（禁止的模式），从而影响了该系列的确定性。</p><p>​        当前的大多数研究都集中在考虑顺序模式的频率来计算置换熵HO上，该方法并未揭示顺序模式之间的过渡行为。 因此，HO是静态的。 例如，仅在HO值为1.92的情况下，图 <strong>2（b，c）</strong> 中的动力学细节仍然不清楚，因为HO并未公开（c）中图 <strong>2（b）</strong> 的独特过渡特性。 从可视化的角度来看，图 <strong>3（a，b）</strong> 中方便地显示了阶跃模式之间的过渡差异。</p><hr><p>page four</p><p><img src="https://img-blog.csdnimg.cn/20210129132127902.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>图2.周期性3D序列（x（t），y（t），z（t））的玩具模型及其相关的订购模式直方图。<br>（a）x（t），y（t）和z（t）的周期为2。（b）x（t）和y（t）的周期为2，而z（t）的周期为3。  c）x（t）的周期为2，y（t）和z（t）的周期为3。（d）x（t），y（t）和z（t）的周期为3。各自的频率曲线 时间序列下方显示了序数模式的变化，图例中显示了熵值HO</p><hr><p>提供代码如下：</p><pre><code class="bash">clear;clc%a组初始数据,x,y,z周期为2% x=[1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1];% y=[-2 2 -2 2 -2 2 -2 2 -2 2 -2 2 -2 2 -2 2 -2 2 -2 2 -2];% z=[3 -3 3 -3 3 -3 3 -3 3 -3 3 -3 3 -3 3 -3 3 -3 3 -3 3];%b组初始数据，x,y周期为2，z周期为3 % x=[1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1];% y=[2.5 -2.5 2.5 -2.5 2.5 -2.5 2.5 -2.5 2.5 -2.5 2.5 -2.5 2.5 -2.5 2.5 -2.5 2.5 -2.5 2.5 -2.5 2.5];% z=[-3 3 1 -3 3 1 -3 3 1 -3 3 1 -3 3 1 -3 3 1 -3 3 1];% %c组初始数据，x周期为2，y、z周期为3 % x=[1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1];% y=[-2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1];% z=[3 0.5 1 3 0.5 1 3 0.5 1 3 0.5 1 3 0.5 1 3 0.5 1 3 0.5 1];% %d组初始数据，x、y、z周期为3 % x=[-1 -0.5 1 -1 -0.5 1 -1 -0.5 1 -1 -0.5 1 -1 -0.5 1 -1 -0.5 1 -1 -0.5 1];% y=[-2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1 -2.5 2.5 1];% z=[3 0.5 1 3 0.5 1 3 0.5 1 3 0.5 1 3 0.5 1 3 0.5 1 3 0.5 1];n=length(x);         %%获取原始时间序列的长度delta_x=diff(x);     %%求x的差分delta_y=diff(y);     %%求y的差分delta_z=diff(z);     %%求z的差分m=length(delta_x);   %%获得差分长度%--------------------------------------------------------------------------%记录π序数pai_xushu=cell(1,m);      %%直观显示对应的π模式digit_xushu=zeros(1,m);   %%编程序简易，以1-&gt;π1,2-&gt;π2，…，n-&gt;πnfor i=1:m            %%得到m个π序数    if delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π1&#39;;        digit_xushu(i)=1;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π2&#39;;        digit_xushu(i)=2;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π3&#39;;        digit_xushu(i)=3;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π4&#39;;        digit_xushu(i)=4;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π5&#39;;        digit_xushu(i)=5;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π6&#39;;        digit_xushu(i)=6;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π7&#39;;        digit_xushu(i)=7;    else        pai_xushu&#123;i&#125;=&#39;π8&#39;;        digit_xushu(i)=8;    endend%记录π模式概率p(πi)及其相应的熵值Hopai_count=zeros(1,8);for i=1:m    for j=1:8    if digit_xushu(i)==j        pai_count(j)=pai_count(j)+1;      %%记录对应的πi出现的个数    end        endendP=pai_count/sum(pai_count);               %%获得每个πi占总体的比例Ho=0;for j=1:8    if P(j)~=0    Ho=Ho-P(j)*log2(P(j));    endend%绘图区i=1:n;        %%画生成x、y、z图对应需要x轴j=1:m;        %%画差分增量模式图需要x轴figure(1);subplot(2,1,1);plot(i,x,&#39;-&#39;);hold on;plot(i,y,&#39;m-&#39;);hold on;plot(i,z,&#39;b-&#39;);hold off;xlabel(&#39;t&#39;);ylabel(&#39;x,y,z&#39;);subplot(2,1,2);bar(P);         %%画直方图xlabel(&#39;π_i&#39;);ylabel(&#39;p(π_i)&#39;);text(4,0.2,[&#39;H_o=&#39; num2str(Ho)]);      %%在图形对应位置上显示πi</code></pre><p>结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20210129165132229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>基本达到了要求</p><hr><p>与3维不相关的独立相同的分布随机均匀噪声相比，有序分区网络是一个完整的连接图（图<strong>3（c）</strong>）。 另外，在序列的时间迭代之后，我们通过其过渡频率wij = p（πi→πj）指示每个有向链路。 最后，我们得出一个加权有向网络，其特征在于加权邻接矩阵W = {wij}，i，j∈[1，2 ^ n]。 矩阵W满足归一化∑ i，j-&gt; 2 ^ n wij = 1。 在此，基于W，通过香农熵HT量化有序模式转换特性的规律性，即</p><p><img src="https://img-blog.csdnimg.cn/20210129132229502.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-D1g81NJU-1611895510083)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110145254332.png)]"></p><p>总和遍及所有可能的2 ^ 2n转换。 完全类似于HO，对于一个n维独立的相同分布随机过程，可以获得最大熵HT = 2n。</p><p>​        对于由随机过程产生的时间序列，计算HT相当简单。 但是，我们需要注意连续系统的情况，该系统在生成的网络中会产生较大比例的自环，如下所示。 这里我们以混沌的Rössler系统为例</p><p><img src="https://img-blog.csdnimg.cn/20210129132245786.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Lp6vRcwq-1611895510083)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110145447416.png)]"></p><p>其中a = 0.165，ω= 1.0。 公式 <strong>（4）</strong> 通过四阶Runge Kutta方法进行数值积分，积分步骤h = 0.01。 丢弃前10000个瞬态数据点，并分析由N = 500000个数据点组成的时间序列。 时间序列的短段（x，y，z）如图 <strong>4（a）</strong> 所示。 由于系统的连续性，在某些时间间隔内有许多高原会影响顺序模式的不变性（图 <strong>4（b）</strong> ）。 这些高原通过最终的过渡网络中的自环来完成（图 <strong>4（c）</strong> ）。 在现有的大多数复杂网络研究中，由于计算简单和理论上的考虑，都避免了自环 <strong>[46]</strong> 。 在Rössler系统的情况下，大约有99％的自环，而只有大约1％的非自环（如图 <strong>4（c）</strong> 中的箭头所示）。</p><hr><p>page five</p><p><img src="https://img-blog.csdnimg.cn/2021012913232112.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-I4ADa7cL-1611895510084)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110145850164.png)]"></p><p>图3.（a）分别用于图 <strong>2（b）</strong> 的周期性过程的序数分区过渡网络，（b）用于图 <strong>2（c）</strong> 。 面板（c）对应于3D独立的相同分布随机均匀噪声，其中链接箭头（双向）被抑制以便于可视化。</p><hr><p><img src="https://img-blog.csdnimg.cn/20210129132353688.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ifr78ft4-1611895510084)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110145938048.png)]"></p><p>图4.混沌Rössler系统（a = 0.165）：（a）时间序列的短段（x，y，z），（b）与（a，c）顺序模式的特定时间窗口相对应的顺序模式的时间变化 有自环的跃迁网络，HO = 2.283，（d）没有自环的跃迁网络，HT = 2.585，其中观察到过渡路径π1→π5→π6→π8→π4→π3→π1。 链接上的值表示顺序模式的相应转换频率。 注意，在获得（c，d）中使用了N ＝ 500000个数据点。</p><hr><p>提供代码如下：</p><pre><code class="bash">%%混Rossler系统-公式,四阶Runge Kutta方法  历时 16.848760 秒。%初始数据clear;clcticglobal w         %%定义全局变量wglobal a;        %%定义全局变量aN=500000;h=0.01;  %%迭代N次，步长h；w=1.0;a=0.165;   %%设定w,ax=zeros(1,N);y=zeros(1,N);z=zeros(1,N);   %%提前分配内存空间x(1)=0;y(1)=8;z(1)=0.5;  %%设定初始点%四阶Runge-Kutta算法for i=1:N    x_k1=f_dx(y(i),z(i));       %%调用自编写f_dx函数    y_k1=f_dy(x(i),y(i));       %%调用自编写f_dy函数    z_k1=f_dz(x(i),z(i));       %%调用自编写f_dz函数        x_k2=f_dx(y(i)+h/2*y_k1,z(i)+h/2*z_k1);    y_k2=f_dy(x(i)+h/2*x_k1,y(i)+h/2*y_k1);    z_k2=f_dz(x(i)+h/2*x_k1,z(i)+h/2*z_k1);        x_k3=f_dx(y(i)+h/2*y_k2,z(i)+h/2*z_k2);    y_k3=f_dy(x(i)+h/2*x_k2,y(i)+h/2*y_k2);    z_k3=f_dz(x(i)+h/2*x_k1,z(i)+h/2*z_k2);        x_k4=f_dx(y(i)+h*y_k3,z(i)+h*z_k3);    y_k4=f_dy(x(i)+h*x_k3,y(i)+h*y_k3);    z_k4=f_dz(x(i)+h*x_k3,z(i)+h*z_k3);        x(i+1)=x(i)+h/6*(x_k1+2*x_k2+2*x_k3+x_k4);    y(i+1)=y(i)+h/6*(y_k1+2*y_k2+2*y_k3+y_k4);    z(i+1)=z(i)+h/6*(z_k1+2*z_k2+2*z_k3+z_k4);end%获得x,y,z序列后进行差分delta_x=diff(x);      %%对余下的x序列进行差分       delta_y=diff(y);      %%对余下的y序列进行差分delta_z=diff(z);      %%对余下的z序列进行差分m=length(delta_x);    %%获取余下的x序列长度%记录π序数pai_xushu=cell(1,m);        %%直观显示对应的π模式digit_xushu=zeros(1,m);     %%编程序简易，以1-&gt;π1,2-&gt;π2，…，n-&gt;πnfor i=1:m                   %%得到m个π序数    if delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π1&#39;;        digit_xushu(i)=1;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π2&#39;;        digit_xushu(i)=2;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π3&#39;;        digit_xushu(i)=3;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π4&#39;;        digit_xushu(i)=4;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π5&#39;;        digit_xushu(i)=5;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π6&#39;;        digit_xushu(i)=6;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π7&#39;;        digit_xushu(i)=7;    else        pai_xushu&#123;i&#125;=&#39;π8&#39;;        digit_xushu(i)=8;    endend%丢失前clear_N个数据点clear_N=10000;             %%设定丢弃数据点x_clear=x(1:clear_N);x(1:clear_N)=[];   %%x前clear_N个数据点存入x_clear     y_clear=y(1:clear_N);y(1:clear_N)=[];   %%y前clear_N个数据点存入y_clearz_clear=z(1:clear_N);z(1:clear_N)=[];   %%z前clear_N个数据点存入z_cleardigit_xushu_clear_N=digit_xushu(1:clear_N);digit_xushu(1:clear_N)=[];m=length(digit_xushu);%计算记录π模式概率p(πi)及其相应的熵值Hopai_count=zeros(1,8);for i=1:m    for j=1:8    if digit_xushu(i) == j        pai_count(j)=pai_count(j)+1;   %%记录对应πi出现的个数    end        endendP=pai_count/sum(pai_count);      %%获得每个πi占总体的比例Ho=0;P(find(P==0))=1;       %%消除概率为0取歧义对数的情况，log2(1)=0,不影响最后熵值结果for j=1:8    Ho=Ho-P(j)*log2(P(j));endP(find(P==1))=0;       %%复原disp(&#39;π模式出现的概率及其对应的熵Ho&#39;);for i=1:8    if P(i)~=0        disp([&#39;π&#39; num2str(i) &#39; is &#39; num2str(P(i))]);    %%控制台上显示单个πi对应的概率    endendHodisp(&#39;---------------------------------------------&#39;);%计算π模式的转化概率以及HTpai_ij_count=zeros(8,8);for k=1:m-1    for i=1:8        for j=1:8            if digit_xushu(k) == i &amp;&amp; digit_xushu(k+1) == j    %%如果第k个π模式为πi,第k+1个π模式为πj                pai_ij_count(i,j)=pai_ij_count(i,j)+1;         %%则在第i行第j列+1。最后可得到转移数量矩阵。            end        end    endendP_ij=pai_ij_count/sum(sum(pai_ij_count));               %%获得每个πi-&gt;πj的转移概率P_ij(find(P_ij==0))=1;           %%消除概率为0取歧义对数的情况，log2(1)=0,不影响最后熵值结果HT=0;for i=1:8    for j=1:8        HT=HT-P_ij(i,j)*log2(P_ij(i,j));    endendP_ij(find(P_ij==1))=0;     %%复原disp(&quot;π模式传递概率及相应的HT&quot;)for i=1:8    for j=1:8        if P_ij(i,j)~=0            disp([&#39;π&#39; num2str(i) &#39;-&gt;&#39; &#39;π&#39; num2str(j) &#39; is &#39; num2str(P_ij(i,j))] )  %%在控制台显示πi-&gt;πj的转移概率        end    endendHTdisp(&#39;---------------------------------------------------------------------&#39;)%去除自环后的概率及Htpai_ij_count_2=pai_ij_count-diag(diag(pai_ij_count));   %%对角线置0，去除自环现象P_ij_2=pai_ij_count_2/sum(sum(pai_ij_count_2));         %%余下进行归一化得其转移概率P_ij_2(find(P_ij_2==0))=1;     %%消除概率为0取歧义对数的情况，log2(1)=0,不影响最后熵值结果HT_2=0;for i=1:8    for j=1:8        HT_2=HT_2-P_ij_2(i,j)*log2(P_ij_2(i,j));    endendP_ij_2(find(P_ij_2==1))=0;     %%复原disp(&quot;去除自环后，π模式传递概率及相应的HT_2&quot;)for i=1:8    for j=1:8        if P_ij_2(i,j)~=0            disp([&#39;π&#39; num2str(i) &#39;-&gt;&#39; &#39;π&#39; num2str(j) &#39; is &#39; num2str(P_ij_2(i,j))] ) %%在控制台显示πi-&gt;πj（i~=j）的转移概率        end    endendHT_2%%绘图区figure(1);n=3000;     %%短段，长度为ni=1:n;      %%画图所需对应x轴subplot(2,1,1);plot(i,x_clear(i),&#39;-&#39;);hold on;plot(i,y_clear(i),&#39;m-&#39;);hold on;plot(i,z_clear(i),&#39;b-&#39;);hold off;ylabel(&#39;x,y,z&#39;);title(&#39;(a)&#39;);h1=legend(&#39;x&#39;,&#39;y&#39;,&#39;z&#39;);           %%设置图例set(h1,&#39;Orientation&#39;,&#39;horizon&#39;);set(h1,&#39;Box&#39;,&#39;off&#39;);subplot(2,1,2);i=1:n;plot(i,digit_xushu_clear_N(i),&#39;-&#39;);xlabel(&#39;t&#39;);ylabel(&#39;π&#39;);title(&#39;(b)&#39;);  figure(2)for i=1:8    L(i)=length(find(digit_xushu==i));      %%得到出现πi的个数endfor i=1:8    index(i,1:L(i))=find(digit_xushu==i);   %%πi对应在序列中的位置，方便作图endplot3(x(index(1,1:L(1))),y(index(1,1:L(1))),z(index(1,1:L(1))),&#39;c*&#39;);hold on;plot3(x(index(2,1:L(2))),y(index(2,1:L(2))),z(index(2,1:L(2))),&#39;r*&#39;);hold on;plot3(x(index(3,1:L(3))),y(index(3,1:L(3))),z(index(3,1:L(3))),&#39;y*&#39;);hold on;plot3(x(index(4,1:L(4))),y(index(4,1:L(4))),z(index(4,1:L(4))),&#39;k*&#39;);hold on;plot3(x(index(5,1:L(5))),y(index(5,1:L(5))),z(index(5,1:L(5))),&#39;m*&#39;);hold on;plot3(x(index(6,1:L(6))),y(index(6,1:L(6))),z(index(6,1:L(6))),&#39;b*&#39;);hold on;plot3(x(index(7,1:L(7))),y(index(7,1:L(7))),z(index(7,1:L(7))),&#39;k*&#39;);hold on;plot3(x(index(8,1:L(8))),y(index(8,1:L(8))),z(index(8,1:L(8))),&#39;g*&#39;);hold off;h1=legend(&#39;π_1&#39;,&#39;π2&#39;,&#39;π_3&#39;,&#39;π_4&#39;,&#39;π_5&#39;,&#39;π_6&#39;,&#39;π_8&#39;);    %%设置图例set(h1,&#39;Box&#39;,&#39;off&#39;);toc%由公式4所得函数function f=f_dx(y,z)     %%dx/dtglobal wf=-w*y-z;endfunction f=f_dy(x,y)     %%dy/dtglobal wglobal af=w*x+a*y;endfunction f=f_dz(x,z)     %%dz/dtf=0.4+z*(x-8.5);end</code></pre><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/20210129165812844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210129165832638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>基本达到了原文献的要求~   上面的代码也会顺应求出图六的图形，图四、六用的都是同一个混沌Rossler系统</p><hr><p>page six</p><p><img src="https://img-blog.csdnimg.cn/20210129161856402.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mVGpa661-1611895510085)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110150315091.png)]"></p><p>图5.Hénon映射：（a）吸引子，（b）时间序列的分段，（c）顺序模式的直方图导致HO =1.5和（d）顺序模式转换网络去除了自环，从而产生HT = 1.76。</p><hr><p>提供代码如下：</p><pre><code class="bash">%初始数据clear;clcn=30;                      %%设定时间序列长度x=zeros(1,n);y=zeros(1,n);x(1)=0.76;y(1)=0;           %%设定初值for i=2:n                   %%迭代得到完整的序列值    x(i)=y(i-1)+1-1.4*x(i-1)^2;    y(i)=0.3*x(i-1);enddelta_x=diff(x);          %%求x的差分delta_y=diff(y);          %%求y的差分m=length(delta_x);        %%获取差分长度%记录π序数pai_xushu=cell(1,m);       %%直观显示对应的π模式digit_xushu=zeros(1,m);    %%编程序简易，以1-&gt;π1,2-&gt;π2，…，n-&gt;πnfor i=1:m                  %%得到m个π序数    if delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π1&#39;;        digit_xushu(i)=1;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π2&#39;;        digit_xushu(i)=2;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π3&#39;;        digit_xushu(i)=3;    else        pai_xushu&#123;i&#125;=&#39;π4&#39;;        digit_xushu(i)=4;    endendpai_count=zeros(1,4);for i=1:m    for j=1:4    if digit_xushu(i)==j        pai_count(j)=pai_count(j)+1;    %%记录对应πi出现的个数    end        endendP=pai_count/sum(pai_count);             %%获得每个πi占总体的比例Ho=0;P(find(P==0))=1;     %%消除概率为0取歧义对数的情况，log2(1)=0,不影响最后熵值结果for j=1:4    Ho=Ho-P(j)*log2(P(j));endP(find(P==1))=0;     %%复原%计算π模式转移概率pai_ij_count=zeros(4,4);for k=1:m-1    for i=1:4        for j=1:4            if digit_xushu(k) == i &amp;&amp; digit_xushu(k+1) == j    %%如果第k个π模式为πi,第k+1个π模式为πj                pai_ij_count(i,j)=pai_ij_count(i,j)+1;         %%则在i行j列+1。最后可得到转移数量矩阵。            end        end    endendP_ij=pai_ij_count/sum(sum(pai_ij_count));  %%获得每个πi-&gt;πj的转移概率    P_ij(find(P_ij==0))=1;           %%消除概率为0取歧义对数的情况，log2(1)=0,不影响最后熵值结果HT=0;for i=1:4    for j=1:4        HT=HT-P_ij(i,j)*log2(P_ij(i,j));    endendP_ij(find(P_ij==1))=0;     %%复原disp(&quot;未去除自环时的概率矩阵P_ij及相应的HT&quot;)P_ij,HTfor i=1:4    for j=1:4        if P_ij(i,j)~=0            disp([&#39;π&#39; num2str(i) &#39;-&gt;&#39; &#39;π&#39; num2str(j) &#39; is &#39; num2str(P_ij(i,j))] )  %%在控制台显示        end    endenddisp(&#39;---------------------------------------------------------------------&#39;)%去除自环后的概率pai_ij_count_2及Ht_2pai_ij_count_2=pai_ij_count-diag(diag(pai_ij_count));   %%对角线置0，去除自环现象P_ij_2=pai_ij_count_2/sum(sum(pai_ij_count_2));         %%余下进行归一化得其转移概率P_ij_2(find(P_ij_2==0))=1;        %%消除概率为0取歧义对数的情况，log2(1)=0,不影响最后熵值结果HT_2=0;for i=1:4    for j=1:4        HT_2=HT_2-P_ij_2(i,j)*log2(P_ij_2(i,j));    endendP_ij_2(find(P_ij_2==1))=0;     %复原disp(&quot;去除自环时的概率矩阵P_ij_2及相应的HT_2&quot;)P_ij_2,HT_2for i=1:4    for j=1:4        if P_ij_2(i,j)~=0            disp([&#39;π&#39; num2str(i) &#39;-&gt;&#39; &#39;π&#39; num2str(j) &#39; is &#39; num2str(P_ij_2(i,j))] )  %%在控制台显示        end    endend%%绘图区figure(1);%图asubplot(2,2,1);x1=-1.5:0.01:1.5;y1=1.4*x1.^2+x1-1;          %%L1x2=-1.5:0.01:1.5;y2=0.3*x2;                  %%L2plot(x1,y1,&#39;m-&#39;);hold on;plot(x2,y2,&#39;m-&#39;);hold on;xlabel(&#39;x&#39;);ylabel(&#39;y&#39;);title(&#39;(a)&#39;)for i=1:4    L(i)=length(find(digit_xushu==i));endfor i=1:4    index(i,1:L(i))=find(digit_xushu==i);endplot(x(index(1,1:L(1))),y(index(1,1:L(1))),&#39;b*&#39;);hold on;plot(x(index(2,1:L(2))),y(index(2,1:L(2))),&#39;r*&#39;);hold on;plot(x(index(3,1:L(3))),y(index(3,1:L(3))),&#39;*&#39;);hold on;plot(x(index(4,1:L(4))),y(index(4,1:L(4))),&#39;m*&#39;);hold off;%图bsubplot(2,2,2);i=1:n;      %%画生成x、y对应的图需x轴plot(i,x,&#39;-&#39;);hold on;plot(i,y,&#39;m-&#39;);hold on;hold off;xlabel(&#39;t&#39;);ylabel(&#39;x,y&#39;);title(&#39;b&#39;);h1=legend(&#39;x&#39;,&#39;y&#39;);              %%设置图例格式set(h1,&#39;Orientation&#39;,&#39;horizon&#39;);set(h1,&#39;Box&#39;,&#39;off&#39;);%图csubplot(2,2,3);bar(P);xlabel(&#39;π_i&#39;);ylabel(&#39;p(π_i)&#39;);title(&#39;c&#39;);text(3.3,0.3,[&#39;H_o=&#39; num2str(Ho)]);      %%在图形对应位置上显示H_o</code></pre><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/202101291708078.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210129170832777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我选取的时间序列长度为30，基本达到了文献要求的结果</p><hr><p>加权邻接矩阵W可以分为对角和非对角项。 考虑到数值观察结果，W（自环）的对角元素远大于非对角元素Eq（3）简化为</p><p><img src="https://img-blog.csdnimg.cn/2021012916194967.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nK73LROL-1611895510085)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110150555636.png)]"></p><p>因此，当考虑到自环时，我们得到一个连续系统的HT≈HO。 在这种情况下，HT很难捕获不同顺序模式之间的过渡。</p><p>​        为了强调序数模式之间非自我过渡的重要性，我们通过将W中的对角线值设置为0来移除如图 <strong>4（d）</strong> 所示的自环。这是大多数关于复数的研究工作的典型 网络 <strong>[46]</strong> 。 此外，我们在计算加权矩阵W之前删除自环，以保持标准化∑i，j-&gt; 2 ^ n wij = 1。 请注意，在随机过程中不应期望大量的自循环</p><p><strong><u>相空间的序数模式分区。</u></strong> 顺序模式转换网络为我们提供了相空间分区的替代方案，该方案利用了系统的零线。 在这里，我们显示了两个涉及离散和连续动力系统的示例。<br>示例（1）：Hénon地图</p><p><img src="https://img-blog.csdnimg.cn/20210129162002910.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TVZddflM-1611895510087)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110151006366.png)]"></p><p>选择作为一个混沌二维地图的示例。 吸引子的顺序模式分区如图 <strong>5（a）</strong> 所示，按不同的顺序模式进行颜色编码。 时间序列的一部分如图 <strong>5（b）</strong> 所示。阶数模式的直方图（图 <strong>5（c）</strong> ）发现π4是系统的禁止模式，其HO = 1.50。 相应的序数分区过渡网络如图 <strong>5（d）</strong> 所示，每条链路的频率以雾度表示，得出HT = 1.76。</p><hr><p>page seven</p><p><img src="https://img-blog.csdnimg.cn/20210129162026572.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ucepVri1-1611895510087)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110151431695.png)]"></p><p>图6.（a）相序颜色编码的相空间中的Rössler吸引子（a = 0.165），由图例表示。 没有观察到模式π2和π7。  （b）上图是变量x，y和z之间的激活-抑制关系，其中激活用普通箭头表示，而抑制用禁止箭头47表示； 下面板代表系统所有允许的（不一定要观察到的）模式转换。 相应的顺序分区转换网络如图4<strong>（d）</strong>所示。 面板（c）与（a）的a = 0.26相同，其中突出显示了大量π2模式，（d）是有序分区转换网络（不包括自环），其中从π4进行了替代转换 →观察到π2→π1</p><hr><p>代码见图4那里，这里附上跑出来的图<br>a=0.165时<br><img src="https://img-blog.csdnimg.cn/20210129170226706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>a=0.26时<br><img src="https://img-blog.csdnimg.cn/20210129170404500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>达到了文献的效果</p><hr><p>​        根据表<strong>1</strong>中的顺序模式定义，Hénon映射的相空间分区被nullclines占用，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20210129162042315.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6EchqpRp-1611895510088)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110151911251.png)]"></p><p>这两条线如图 <strong>5（a）</strong> 所示，无论迭代步骤如何，我们都没有发现吸引子的点位于有序模式π4的区域中。  π4模式的消失表明，除了（0.63，0.19）的不稳定固定点（L1和L2的交点）之外，π4分区与吸引子之间没有交集。</p><p>​        示例（2）：Rössler系统，选择公式 <strong>4</strong> 作为连续动力系统。 当参数a = 0.165时，吸引子如图 <strong>6（a）</strong> 所示，相空间点由序号模式进一步进行颜色编码。 每个分区的边界由相应的零线确定，即dx / dt = 0，dy / dt = 0和dz / dt = 0。 顺序模式转换网络如图 <strong>4（d）</strong> 所示。 在这种情况下，π2和π7均不出现，解释如下 <strong>[47]</strong> 。 当将相空间转换为序数分区转换网络时，我们将每个状态（x，y，z）与诸如（+，-，+）之类的顺序模式相关联（如表 <strong>2</strong> 所示）。 此三维顺序模式描述了（x，y，z）的哪些变量在给定时间增加和减少。以变量x为例，由于雅可比行列式中的负号（-ω和-1），y和z都是x的抑制器。 但是，x是变量y的激活器，因为雅可比矩阵的元素在相空间中的每个地方都是ω为正。  Rössler系统的激活和抑制方案如图<strong>6（b）</strong>所示。</p><hr><p>page eight</p><p>​        轨迹可以越过零线的条件意味着从增加到减少（反之亦然）相当于确定局部最大值或最小值。 由于系统的连续性，我们具有以下规则以具有最大值或最小值 <strong>[47]</strong> ：（i）如果变量的所有阻遏物都减少而其所有激活物都增加，则变量不能具有最大值；  （ii）如果变量的所有阻遏物都在增加而其所有的激活物都在减少，则变量不能具有最小值。 这两个规则产生了不同顺序模式之间的所有可能过渡，如图 <strong>6（b）</strong> 所示。 然而，在相空间中的典型轨迹观察到的过渡网络由给定的参数a和ω集合确定。 对于a = 0.165和ω= 1的情况，我们仅找到过渡路径π1→π5→π6→π8→π4→π3→π1（如图<strong>4（d）</strong> 所示），同时π2和π7是禁止的模式。 将a的值增加到0.26，Rössler系统呈现出具有不规则突跳的螺旋型混沌振荡，如图 <strong>6（c）</strong> 所示，产生了从π4→π2→π1的替代跃迁。 在此之前，我们观察到模式从π4到π1的两条过渡路径（图 <strong>6（d）</strong> ），而π7仍然不存在。 换句话说，π2图案的出现表明有序图案的变化对吸引子的几何变化敏感。</p><p><strong><u>识别动态过渡。</u></strong> 我们使用序数分区过渡网络来识别两种不同情况下的动态过渡：（i）相干到非相干过渡，这是一个弱混沌-混沌过渡，（ii）到相同步过渡的路径。 在两个示例中，我们都显示了有序模式（无自环）的频率图，HO（有自环）和HT（无自环）的复杂度熵度量。此外，我们将情况（i）与相干性进行了比较 指数（CI）和情况（ii）表示每个振荡器的平均旋转频率Ωi。</p><p>​        例（1）显示了混沌Rössler系统（公式<strong>（4）</strong>）中的相干到非相干转变，其中参数a在[0.15，0.25]范围内系统地变化。 正如参考文献中系统显示的那样。 如图<strong>48</strong>所示，该参数范围包括不同的动力学，包括周期性窗口，相位相干混沌（在相空间中存在明确定义的旋转中心）以及非相位相干混沌振荡（缺少明显的旋转中心）。 相位相干和非相位相干混沌之间的过渡出现在ac≈0.206。 更具体地说，对于&lt;ac，混沌吸引子始终是相干的，而对于a&gt; ac，它们是非相干的。 我们推荐读者参考。  <strong>[48]</strong> 进一步讨论了各种检测此混沌-混沌过渡的方法以及周期性窗口，这些方法包括传统的相干因子，相扩散系数，基于递归量化的鉴别器和基于递归网络的度量。 在这项工作中，为了避免重复，我们仅讨论序数模式变化以及熵HO和HT通过与相干指数的度量进行比较来检测从相干混沌到非相干混沌的过渡的能力（请参见方法）。</p><p>​        图<strong>7</strong>显示了更改参数a时的分叉图。 首先，当a ＜ac时，有序模式π2的频率为零（f（π2）＝ 0），而当a＞ ac时，其频率为正。 相反，当a&gt; ac时，f（π3）减小（图 <strong>7（a）</strong> ）。 对于其他顺序模式π1，π4，π5，π6和π8，观察到的变化要小得多。 模式π7不会出现在a的整个间隔中。 顺序模式π2和π3对吸引子的几何变化敏感，捕获从相干相态到非相干态的过渡。</p><p>​        此外，当a &lt;ac时，HO的变化很小，而HT为常数（图 <strong>7（b）</strong> ）。  HO和HT的行为已被相干指数（参见方法）证实，如图 <strong>7（c）</strong> 所示。 同时，当控制参数a向相干和非相干状态之间的过渡点增加时，我们发现这些措施存在一些差异。 特别是，HO和相干指数在过渡点ac之前都略有增加，而HT在ac处急剧增加，如图 <strong>7</strong> 中的垂直虚线所示，这是由于原点处的同斜点。 当控制参数a在相干状态下增加时，吸引子会连续增长并最终延伸到原点附近，然后过渡到漏斗状态，在漏斗状态中轨迹的唯一旋转中心会丢失。 每当轨迹接近均斜点时，（x，y）平面中的动力学就会变得非常慢。 结果，在原点附近的轨迹上存在高密度的采样点。 同时，这些到原点的重新注入和从原点的弹出都是相当不规则的事件，这在HO和相干指数的计算中引入了波动。 相反，在计算HT时，局部速度仅在过渡到非相干相干状态后才从增加到减少（反之亦然）改变方向。 因此，当控制参数a经过从相干相态到非相干态的过渡时，HT对局部速度空间的变化表现出良好的敏感性，如图 <strong>7</strong> 所示。</p><p>​        注意，HO，HT和相干指数的所有度量在周期性窗口中（例如，在a = 0.227和a = 0.245时）都显示出明显的局部最大值 <strong>48</strong> 。<br>例（2）显示了相位同步的路径，这由三个扩散耦合的Rössler系统通过x组件 <strong>49</strong> 演示。  方程阅读</p><p><img src="https://img-blog.csdnimg.cn/20210129162109468.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nXl5CsjJ-1611895510090)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110153836221.png)]"></p><p>其中k = 1、2、3和κ是耦合强度。 我们通过选择ω1= 0.98，ω2= 1.02，ω3= 1.06来考虑不同的振荡器。 参数a选择为0.165，以使子系统处于相干状态（图 <strong>6（a）</strong> ）。 振荡器k = 2双向耦合到k = 1和k = 3，而在k = 1和k = 3之间没有直接耦合。 公式 <strong>（8）</strong> 通过四阶Runge Kutta方法进行数值积分，积分步骤h = 0.01。 丢弃前10000个瞬态数据点，并分析由150000个数据点组成的时间序列。 我们按照表 <strong>2</strong> 中所示的相同模式定义，从xk分量（即（x1，x2，x3））构造有序模式转换网络。</p><hr><p>page nine</p><p><img src="https://img-blog.csdnimg.cn/20210129162122704.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UOMxtKVG-1611895510092)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110154159840.png)]"></p><p>图7.Rössler系统的相干相干到非相干相干转变作为参数a的函数（误差线表示从系统的100个独立实现中为a的每个值获得的标准偏差：（a）每个序数模式的频率 f（πi），其中π1，π4，π5，π6和π8在a的整个范围内重叠。（b）熵值HO和HT，（c）相干指数（CI）。 垂直虚线突出显示了相干。</p><hr><p>此处的关键是如何算CI（相干指数），通过了解公式（9）（10）（12）以及文献 **[48]**，我对CI的求法有了一定认识。首先获取得到一串π模式的时间序列，对其进行扩充到复平面的操作（希尔伯特变换），matlab自带了hilbert函数，可帮助扩充到复平面.随后可得到φ(t)，对φ(t)进行一阶差分，即Z=diff(φ)，H（-）为heavisde函数，当括号内的数值大于0时记为1，否则记0.对Z使用heavisde函数后进行求均值即得到CI。<br>代码如下：</p><pre><code class="bash">%初始数据，历时 452.128370 秒。clear;clcticglobal w          %%定义全局变量wglobal a;         %%定义全局变量aN=150000;h=0.01;  %%迭代N次，步长h；w=1.0;iter=1;for a=0.15:0.001:0.25   %对a，间隔0.001进行迭代    x=zeros(1,N);y=zeros(1,N);z=zeros(1,N);   %%提前分配内存空间x(1)=rand;y(1)=10*rand;z(1)=rand;  %设定初始点    %四阶Runge-Kutta算法for i=1:N    x_k1=f_dx(y(i),z(i));    y_k1=f_dy(x(i),y(i));    z_k1=f_dz(x(i),z(i));        x_k2=f_dx(y(i)+h/2*y_k1,z(i)+h/2*z_k1);    y_k2=f_dy(x(i)+h/2*x_k1,y(i)+h/2*y_k1);    z_k2=f_dz(x(i)+h/2*x_k1,z(i)+h/2*z_k1);        x_k3=f_dx(y(i)+h/2*y_k2,z(i)+h/2*z_k2);    y_k3=f_dy(x(i)+h/2*x_k2,y(i)+h/2*y_k2);    z_k3=f_dz(x(i)+h/2*x_k1,z(i)+h/2*z_k2);        x_k4=f_dx(y(i)+h*y_k3,z(i)+h*z_k3);    y_k4=f_dy(x(i)+h*x_k3,y(i)+h*y_k3);    z_k4=f_dz(x(i)+h*x_k3,z(i)+h*z_k3);        x(i+1)=x(i)+h/6*(x_k1+2*x_k2+2*x_k3+x_k4);    y(i+1)=y(i)+h/6*(y_k1+2*y_k2+2*y_k3+y_k4);    z(i+1)=z(i)+h/6*(z_k1+2*z_k2+2*z_k3+z_k4);end%丢弃前clear_N个数据点后进行差分clear_N=10000;x(1:clear_N)=[];y(1:clear_N)=[];z(1:clear_N)=[];delta_x=diff(x);delta_y=diff(y);delta_z=diff(z);m=length(delta_x);%记录π序数pai_xushu=cell(1,m);              %%直观显示对应的π模式digit_xushu=zeros(1,m);           %%编程序简易，以1-&gt;π1,2-&gt;π2，…，n-&gt;πnfor i=1:m                         %%得到m个π序数    if delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π1&#39;;        digit_xushu(i)=1;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π2&#39;;        digit_xushu(i)=2;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π3&#39;;        digit_xushu(i)=3;    elseif delta_x(i)&gt;=0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π4&#39;;        digit_xushu(i)=4;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π5&#39;;        digit_xushu(i)=5;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&gt;=0 &amp;&amp; delta_z(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π6&#39;;        digit_xushu(i)=6;    elseif delta_x(i)&lt;0 &amp;&amp; delta_y(i)&lt;0 &amp;&amp; delta_z(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π7&#39;;        digit_xushu(i)=7;    else        pai_xushu&#123;i&#125;=&#39;π8&#39;;        digit_xushu(i)=8;    endend%计算记录π模式概率p(πi)及其相应的熵值Hopai_count=zeros(1,8);for i=1:m    for j=1:8    if digit_xushu(i) == j        pai_count(j)=pai_count(j)+1;   %%记录对应πi出现的个数    end        endendP(:,iter)=pai_count/sum(pai_count);   %%获得每个πi占总体的比例P(find(P(:,iter)==0),iter)=1;     %%消除概率为0取歧义对数的情况，log2(1)=0,不影响最后熵值结果Ho(iter)=0;for j=1:8    Ho(iter)=Ho(iter)-P(j,iter)*log2(P(j,iter));endP(find(P(:,iter)==1),iter)=0;     %%复原%计算π模式的转化概率以及HTpai_ij_count=zeros(8,8);for k=1:m-1    for i=1:8        for j=1:8            if digit_xushu(k) == i &amp;&amp; digit_xushu(k+1) == j  %%如果第k个π模式为πi,第k+1个π模式为πj                pai_ij_count(i,j)=pai_ij_count(i,j)+1;       %%则在第i行第j列+1。最后可得到转移数量矩阵。            end        end    endendP_ij=pai_ij_count/sum(sum(pai_ij_count));          %%获得每个πi-&gt;πj的转移概率P_ij(find(P_ij==0))=1;               %%消除概率为0取歧义对数的情况，log2(1)=0,不影响最后熵值结果HT(iter)=0;for i=1:8    for j=1:8        HT(iter)=HT(iter)-P_ij(i,j)*log2(P_ij(i,j));    endendP_ij(find(P_ij==1))=0;     %%复原%去除自环后的概率及Htpai_ij_count_2=pai_ij_count-diag(diag(pai_ij_count));   %%对角线置0，去除自环现象P_ij_2=pai_ij_count_2/sum(sum(pai_ij_count_2));         %%余下进行归一化得其转移概率P_ij_2(find(P_ij_2==0))=1;            %%消除概率为0取歧义对数的情况，log2(1)=0,不影响最后熵值结果HT_2(iter)=0;for i=1:8    for j=1:8        HT_2(iter)=HT_2(iter)-P_ij_2(i,j)*log2(P_ij_2(i,j));    endendP_ij_2(find(P_ij_2==1))=0;     %%复原%记录相干指数XX=digit_xushu;YY=hilbert(XX);YY=imag(YY);z=atan(XX./YY);Dz=diff(z);CI(iter)=sum(Dz&lt;0)/length(Dz);iter=iter+1;end%%绘图区figure(1)mm=0.15:0.001:0.25;    %%画图所需对应x轴subplot(3,1,1);plot(mm,P(1,:),&#39;b*-&#39;);hold on;plot(mm,P(2,:),&#39;g*-&#39;);hold on;plot(mm,P(3,:),&#39;r*-&#39;);hold on;plot(mm,P(4,:),&#39;c*-&#39;);hold on;plot(mm,P(5,:),&#39;m*-&#39;);hold on;plot(mm,P(6,:),&#39;y*-&#39;);hold on;plot(mm,P(7,:),&#39;k*-&#39;);hold on;plot(mm,P(8,:),&#39;w*-&#39;);hold off;ylabel(&#39;f(π_i)&#39;);% h1=legend(&#39;π_1&#39;,&#39;π_2&#39;,&#39;π_3&#39;,&#39;π_4&#39;,&#39;π_5&#39;,&#39;π_6&#39;,&#39;π_7&#39;,&#39;π_8&#39;);% set(h1,&#39;Orientation&#39;,&#39;horizon&#39;);% set(h1,&#39;Box&#39;,&#39;off&#39;);subplot(3,1,2);[AX,H1,H2]=plotyy(mm,Ho,mm,HT,&#39;plot&#39;);    %%设置双坐标HH1=get(AX(1),&#39;Ylabel&#39;);                  %%设置图例set(HH1,&#39;String&#39;,&#39;H_o&#39;);                  %%设置图例HH2=get(AX(2),&#39;Ylabel&#39;);set(HH2,&#39;String&#39;,&#39;H_T&#39;);subplot(3,1,3)plot(mm,CI,&#39;-&#39;);ylabel(&#39;CI&#39;);toc%由公式4所得函数function f=f_dx(y,z)      %%dx/dtglobal wf=-w*y-z;endfunction f=f_dy(x,y)      %%dy/dtglobal wglobal af=w*x+a*y;endfunction f=f_dz(x,z)      %%dz/dtf=0.4+z*(x-8.5);end</code></pre><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/2021012917183523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们发现此图与文献中的图有些许差异，首先体现在f($π_i$)上,我认为出现这类现象的原因或许是初始点的选取，导致π模式概率和文献有所差异，Ho和HT有和文献中同样的性质，在a=0.206从相干到非相干，a=0.226和a=0.245都出现了局部最大值。这里性质和文献符合。</p><hr><p>​        我们使用公式 <strong>（8）</strong> 的动机是研究相位同步路径上序数模式的变化，重点是具有不同同步机制的过渡网络的演化过程，这比单个Rössler系统的情况更为复杂。 结果如图 <strong>8</strong> 所示。此外，当对等式进行积分时，图片 <strong>8</strong> 的结果已在50个随机初始条件下取平均值由公式 <strong>（8）</strong> 。 </p><p>​        在不同步状态下（κ&lt;κc1= 0.036），三个振荡器几乎独立地演化，因此所有序数模式的频率相同，均为0.125。 仅当κ接近κc1时，梯度变化很小（图 <strong>8（a）</strong> ）。 熵值HT对这些逐渐变化更敏感，表现出明显的下降趋势，而HO似乎是一个常数（图 <strong>8（b）</strong> ）。 每个振荡器的平均旋转频率Ωk（请参见方法）显示在（图 <strong>8（c）</strong> ）中，这在这种耦合方式下没有同步性。</p><p>​        在振荡器k = 1和k = 2之间出现相位同步但在k = 3时不出现相位同步的情况下（κ∈[kc1，kc2] = [0.036，0.077]），我们观察到阶模π1，π2的单调增长趋势 ，π7和π8（图 <strong>8（a）</strong> ）。 此外，我们发现π4和π5模式的增长趋势相对较慢。 相反，发现π3和π6有一些单调递减趋势。 熵值HO和HT都记录了阶次模式的频率变化，显示出逐渐减小的趋势（图 <strong>8（b）</strong> ）。 平均旋转频率Ωk在图 <strong>8（c）</strong> 中显示，其中k = 1和k = 2锁相到相同的旋转频率，但k = 3则不。</p><p>​        在所有振荡器都处于相位同步状态（κ&gt;κc2= 0.077）的状态下，我们发现模式π1，π2，π4，π5，π7，π8的频率收敛到相同的值f（πi）= 1/6，而π3 和π6不存在（图 <strong>8（a）</strong> ）。 换句话说，如果所有振荡器都同步，则会观察到π3和π6的禁止模式。 熵HO显示出类似抛物线的趋势（先增大然后缓慢减小），但是HT为2.585的常数（图 <strong>8（b）</strong> ）。 由于三个振荡器是锁相的，所以所有平均旋转频率都收敛到相同的值（图 <strong>8（c）</strong> ）。</p><p>​        从耦合振荡器的高维系统的观点来看，在从非同步到相位同步的过程中，我们发现过渡网络经历了所有可能的有序模式之间的相当随机的过渡，变成了有限数量的有序模式之间的过渡状态。 如图<strong>9</strong> 所示。此外，如果所有三个振荡器都同步，我们发现π3和π6是禁止模式</p><hr><p>page ten</p><p><img src="https://img-blog.csdnimg.cn/2021012916214370.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cM7lIlLi-1611895510093)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110161456240.png)]"></p><p>图 <strong>8</strong> .三个耦合的Rössler系统的相位同步转换。  （a）每个顺序模式的频率f（πi），（b）熵值HO和HT，（c）每个振荡器的平均旋转频率Ωi。 子系统k1和k2在κc1= 0.036处同步，而k3仅在更强的耦合强度κc2= 0.077时才加入同步。 两个临界耦合值都由垂直虚线突出显示。</p><hr><p>图8讨论多路径情况下的振荡频率的关系，首先我们需要理解公式8的含义。其中有一句话：振荡器k = 2双向耦合到k = 1和k = 3，而在k = 1和k = 3之间没有直接耦合。对此，在我的理解中当k=1或3时，$\sum k_{k,l}$只有一项这一项中的是$k_{1,2}$或者$k_{3,2}$对此，使用四阶Runge Kutta方法会复杂点。<br>提供代码如下：</p><pre><code class="bash">%%公式（8）历时 1855.851394 秒。%初始数据clear;clcticglobal w1global w2global w3global aglobal KLN=150000;h=0.01;  %迭代N次，步长hw1=0.98;w2=1.02;w3=1.06;a=0.165;      %振荡器w，参数aiter=1;for KL=0:0.001:0.1%四阶Runge-Kutta算法x1=zeros(1,N);y1=zeros(1,N);z1=zeros(1,N);x2=zeros(1,N);y2=zeros(1,N);z2=zeros(1,N);x3=zeros(1,N);y3=zeros(1,N);z3=zeros(1,N);x1(1)=rand;y1(1)=10*rand;z1(1)=rand;  %设定第一组初始点x2(1)=rand;y2(1)=10*rand;z2(1)=rand;  %设定第二组初始点x3(1)=rand;y3(1)=10*rand;z3(1)=rand;  %设定第三组初始点for i=1:N    %算k1    x1_k1=f_dx1(x1(i),y1(i),z1(i),x2(i));    y1_k1=f_dy1(x1(i),y1(i));    z1_k1=f_dz(x1(i),z1(i));        x2_k1=f_dx2(x2(i),y2(i),z2(i),x1(i)+x3(i));    y2_k1=f_dy2(x2(i),y2(i));    z2_k1=f_dz(x2(i),z2(i));        x3_k1=f_dx3(x3(i),y3(i),z3(i),x2(i));    y3_k1=f_dy3(x3(i),y3(i));    z3_k1=f_dz(x3(i),z3(i));        %算k2    x1_k2=f_dx1(x1(i)+h/2*x1_k1,y1(i)+h/2*y1_k1,z1(i)+h/2*z1_k1,x2(i)+h/2*x2_k1);    y1_k2=f_dy1(x1(i)+h/2*x1_k1,y1(i)+h/2*y1_k1);    z1_k2=f_dz(x1(i)+h/2*x1_k1,z1(i)+h/2*z1_k1);        x2_k2=f_dx2(x2(i)+h/2*x2_k1,y2(i)+h/2*y2_k1,z2(i)+h/2*z2_k1,x1(i)+h/2*x1_k1+x3(i)+h/2*x3_k1);    y2_k2=f_dy2(x2(i)+h/2*x2_k1,y2(i)+h/2*y2_k1);    z2_k2=f_dz(x2(i)+h/2*x2_k1,z2(i)+h/2*z2_k1);        x3_k2=f_dx3(x3(i)+h/2*x3_k1,y1(i)+h/2*y3_k1,z3(i)+h/2*z3_k1,x2(i)+h/2*x2_k1);    y3_k2=f_dy3(x3(i)+h/2*x3_k1,y1(i)+h/2*y3_k1);    z3_k2=f_dz(x3(i)+h/2*x3_k1,z1(i)+h/2*z3_k1);        %算k3    x1_k3=f_dx1(x1(i)+h/2*x1_k2,y1(i)+h/2*y1_k2,z1(i)+h/2*z1_k2,x2(i)+h/2*x2_k2);    y1_k3=f_dy1(x1(i)+h/2*x1_k2,y1(i)+h/2*y1_k2);    z1_k3=f_dz(x1(i)+h/2*x1_k2,z1(i)+h/2*z1_k2);        x2_k3=f_dx2(x2(i)+h/2*x2_k2,y2(i)+h/2*y2_k2,z2(i)+h/2*z2_k2,x1(i)+h/2*x1_k2+x3(i)+h/2*x3_k2);    y2_k3=f_dy2(x2(i)+h/2*x2_k2,y2(i)+h/2*y2_k2);    z2_k3=f_dz(x2(i)+h/2*x2_k2,z2(i)+h/2*z2_k2);        x3_k3=f_dx3(x3(i)+h/2*x3_k2,y3(i)+h/2*y3_k2,z3(i)+h/2*z3_k2,x2(i)+h/2*x2_k2);    y3_k3=f_dy3(x3(i)+h/2*x3_k2,y3(i)+h/2*y3_k2);    z3_k3=f_dz(x3(i)+h/2*x3_k2,z3(i)+h/2*z3_k2);        %算k4    x1_k4=f_dx1(x1(i)+h*x1_k3,y1(i)+h*y1_k3,z1(i)+h*z1_k3,x2(i)+h/2*x2_k3);    y1_k4=f_dy1(x1(i)+h*x1_k3,y1(i)+h*y1_k3);    z1_k4=f_dz(x1(i)+h*x1_k3,z1(i)+h*z1_k3);        x2_k4=f_dx2(x2(i)+h*x2_k3,y2(i)+h*y2_k3,z2(i)+h*z2_k3,x1(i)+h*x1_k3+x3(i)+h*x3_k3);    y2_k4=f_dy2(x2(i)+h*x2_k3,y2(i)+h*y2_k3);    z2_k4=f_dz(x2(i)+h*x2_k3,z2(i)+h*z2_k3);        x3_k4=f_dx3(x3(i)+h*x3_k3,y3(i)+h*y3_k3,z3(i)+h*z3_k3,x2(i)+h*x2_k3);    y3_k4=f_dy3(x3(i)+h*x3_k3,y3(i)+h*y3_k3);    z3_k4=f_dz(x3(i)+h*x3_k3,z3(i)+h*z3_k3);        %计算下一时刻    x1(i+1)=x1(i)+h/6*(x1_k1+2*x1_k2+2*x1_k3+x1_k4);    y1(i+1)=y1(i)+h/6*(y1_k1+2*y1_k2+2*y1_k3+y1_k4);    z1(i+1)=z1(i)+h/6*(z1_k1+2*z1_k2+2*z1_k3+z1_k4);        x2(i+1)=x2(i)+h/6*(x2_k1+2*x2_k2+2*x2_k3+x2_k4);    y2(i+1)=y2(i)+h/6*(y2_k1+2*y2_k2+2*y2_k3+y2_k4);    z2(i+1)=z2(i)+h/6*(z2_k1+2*z2_k2+2*z2_k3+z2_k4);        x3(i+1)=x3(i)+h/6*(x3_k1+2*x3_k2+2*x3_k3+x3_k4);    y3(i+1)=y3(i)+h/6*(y3_k1+2*y3_k2+2*y3_k3+y3_k4);    z3(i+1)=z3(i)+h/6*(z3_k1+2*z3_k2+2*z3_k3+z3_k4);end%丢弃前clear_N个数据点clear_N=10000;x1(1:clear_N)=[];x2(1:clear_N)=[];x3(1:clear_N)=[];y1(1:clear_N)=[];y2(1:clear_N)=[];y3(1:clear_N)=[];z1(1:clear_N)=[];z2(1:clear_N)=[];z3(1:clear_N)=[];%--------------------------------------------------------------------------delta_x1=diff(x1);delta_x2=diff(x2);delta_x3=diff(x3);    %%由题目要求，设定xk（k=1,2,3）的时间序列m=length(delta_x1);%记录π序数pai_xushu=cell(1,m);digit_xushu=zeros(1,m);for i=1:m            %%得到m个π序数    if delta_x1(i)&gt;=0 &amp;&amp; delta_x2(i)&gt;=0 &amp;&amp; delta_x3(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π1&#39;;        digit_xushu(i)=1;    elseif delta_x1(i)&gt;=0 &amp;&amp; delta_x2(i)&gt;=0 &amp;&amp; delta_x3(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π2&#39;;        digit_xushu(i)=2;    elseif delta_x1(i)&gt;=0 &amp;&amp; delta_x2(i)&lt;0 &amp;&amp; delta_x3(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π3&#39;;        digit_xushu(i)=3;    elseif delta_x1(i)&gt;=0 &amp;&amp; delta_x2(i)&lt;0 &amp;&amp; delta_x3(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π4&#39;;        digit_xushu(i)=4;    elseif delta_x1(i)&lt;0 &amp;&amp; delta_x2(i)&gt;=0 &amp;&amp; delta_x3(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π5&#39;;        digit_xushu(i)=5;    elseif delta_x1(i)&lt;0 &amp;&amp; delta_x2(i)&gt;=0 &amp;&amp; delta_x3(i)&lt;0        pai_xushu&#123;i&#125;=&#39;π6&#39;;        digit_xushu(i)=6;    elseif delta_x1(i)&lt;0 &amp;&amp; delta_x2(i)&lt;0 &amp;&amp; delta_x3(i)&gt;=0        pai_xushu&#123;i&#125;=&#39;π7&#39;;        digit_xushu(i)=7;    else        pai_xushu&#123;i&#125;=&#39;π8&#39;;        digit_xushu(i)=8;    endend%--------------------------------------------------------------------------delta_x1=diff(x1);delta_y1=diff(y1);delta_z1=diff(z1);   %%x1,y1,z1序列,用来获取Ω1m=length(delta_x1);%记录π序数digit_xushu1=zeros(1,m);for i=1:m            %%得到m个π序数    if delta_x1(i)&gt;=0 &amp;&amp; delta_y1(i)&gt;=0 &amp;&amp; delta_z1(i)&gt;=0        digit_xushu1(i)=1;    elseif delta_x1(i)&gt;=0 &amp;&amp; delta_y1(i)&gt;=0 &amp;&amp; delta_z1(i)&lt;0        digit_xushu1(i)=2;    elseif delta_x1(i)&gt;=0 &amp;&amp; delta_y1(i)&lt;0 &amp;&amp; delta_z1(i)&gt;=0        digit_xushu1(i)=3;    elseif delta_x1(i)&gt;=0 &amp;&amp; delta_y1(i)&lt;0 &amp;&amp; delta_z1(i)&lt;0        digit_xushu1(i)=4;    elseif delta_x1(i)&lt;0 &amp;&amp; delta_y1(i)&gt;=0 &amp;&amp; delta_z1(i)&gt;=0        digit_xushu1(i)=5;    elseif delta_x1(i)&lt;0 &amp;&amp; delta_y1(i)&gt;=0 &amp;&amp; delta_z1(i)&lt;0        digit_xushu1(i)=6;    elseif delta_x1(i)&lt;0 &amp;&amp; delta_y1(i)&lt;0 &amp;&amp; delta_z1(i)&gt;=0        digit_xushu1(i)=7;    else        digit_xushu1(i)=8;    endend%-----------------------------------------------------------------------------------------------------delta_x2=diff(x2);delta_y2=diff(y2);delta_z2=diff(z2);      %%x2,y2,z2序列，用来获取Ω2m=length(delta_x2);%记录π序数digit_xushu2=zeros(1,m);for i=1:m            %%得到m个π序数    if delta_x2(i)&gt;=0 &amp;&amp; delta_y2(i)&gt;=0 &amp;&amp; delta_z2(i)&gt;=0        digit_xushu2(i)=1;    elseif delta_x2(i)&gt;=0 &amp;&amp; delta_y2(i)&gt;=0 &amp;&amp; delta_z2(i)&lt;0        digit_xushu2(i)=2;    elseif delta_x2(i)&gt;=0 &amp;&amp; delta_y2(i)&lt;0 &amp;&amp; delta_z2(i)&gt;=0        digit_xushu2(i)=3;    elseif delta_x2(i)&gt;=0 &amp;&amp; delta_y2(i)&lt;0 &amp;&amp; delta_z2(i)&lt;0        digit_xushu2(i)=4;    elseif delta_x2(i)&lt;0 &amp;&amp; delta_y2(i)&gt;=0 &amp;&amp; delta_z2(i)&gt;=0        digit_xushu2(i)=5;    elseif delta_x2(i)&lt;0 &amp;&amp; delta_y2(i)&gt;=0 &amp;&amp; delta_z2(i)&lt;0        digit_xushu2(i)=6;    elseif delta_x2(i)&lt;0 &amp;&amp; delta_y2(i)&lt;0 &amp;&amp; delta_z2(i)&gt;=0        digit_xushu2(i)=7;    else        digit_xushu2(i)=8;    endend%------------------------------------------------------------------------------------------------------delta_x3=diff(x3);delta_y3=diff(y3);delta_z3=diff(z3);      %%x3,y3,z3序列,用来获取Ω3m=length(delta_x3);%记录π序数digit_xushu3=zeros(1,m);for i=1:m            %%得到m个π序数    if delta_x3(i)&gt;=0 &amp;&amp; delta_y3(i)&gt;=0 &amp;&amp; delta_z3(i)&gt;=0        digit_xushu3(i)=1;    elseif delta_x2(i)&gt;=0 &amp;&amp; delta_y2(i)&gt;=0 &amp;&amp; delta_z2(i)&lt;0        digit_xushu3(i)=2;    elseif delta_x3(i)&gt;=0 &amp;&amp; delta_y3(i)&lt;0 &amp;&amp; delta_z3(i)&gt;=0        digit_xushu3(i)=3;    elseif delta_x3(i)&gt;=0 &amp;&amp; delta_y3(i)&lt;0 &amp;&amp; delta_z3(i)&lt;0        digit_xushu3(i)=4;    elseif delta_x3(i)&lt;0 &amp;&amp; delta_y3(i)&gt;=0 &amp;&amp; delta_z3(i)&gt;=0        digit_xushu3(i)=5;    elseif delta_x3(i)&lt;0 &amp;&amp; delta_y3(i)&gt;=0 &amp;&amp; delta_z3(i)&lt;0        digit_xushu3(i)=6;    elseif delta_x3(i)&lt;0 &amp;&amp; delta_y3(i)&lt;0 &amp;&amp; delta_z3(i)&gt;=0        digit_xushu3(i)=7;    else        digit_xushu3(i)=8;    endend%----------------------------------------------------------------------------------------------------%计算记录π模式概率p(πi)及其相应的熵值Hopai_count=zeros(1,8);for i=1:m    for j=1:8    if digit_xushu(i) == j        pai_count(j)=pai_count(j)+1;        %%记录对应πi出现的个数    end        endendP(:,iter)=pai_count/sum(pai_count);          %%获得每个πi占总体的比例Ho(iter)=0;for j=1:8    if P(j)~=0    Ho(iter)=Ho(iter)-P(j,iter)*log2(P(j,iter));    endend%计算π模式的转化概率以及HTpai_ij_count=zeros(8,8);for k=1:m-1    for i=1:8        for j=1:8            if digit_xushu(k) == i &amp;&amp; digit_xushu(k+1) == j    %%如果第k个π模式为πi,第k+1个π模式为πj                pai_ij_count(i,j)=pai_ij_count(i,j)+1;         %%则在第i行第j列+1。最后可得到转移数量矩阵。            end        end    endendP_ij=pai_ij_count/sum(sum(pai_ij_count));               %%获得每个πi-&gt;πj的转移概率HT(iter)=0;for i=1:8    for j=1:8        if P_ij(i,j)~=0            HT(iter)=HT(iter)-P_ij(i,j)*log2(P_ij(i,j));        end    endend%去除自环后的概率及Htpai_ij_count_2=pai_ij_count-diag(diag(pai_ij_count));   %%对角线置0，去除自环现象P_ij_2=pai_ij_count_2/sum(sum(pai_ij_count_2));         %%余下进行归一化得其转移概率HT_2(iter)=0;for i=1:8    for j=1:8        if P_ij_2(i,j)~=0            HT_2(iter)=HT_2(iter)-P_ij_2(i,j)*log2(P_ij_2(i,j));        end    endend%------------------以下是获得Ωi------------------------%得Ω1XX1=digit_xushu1;YY1=hilbert(XX1);YY1=imag(YY1);z1=atan(XX1./YY1);Dz1=diff(z1);OM1(iter)=mean(Dz1)/(2*pi);%得Ω2XX2=digit_xushu2;YY2=hilbert(XX2);YY2=imag(YY2);z2=atan(XX2./YY2);Dz2=diff(z2);OM2(iter)=mean(Dz2)/(2*pi);%得Ω3XX3=digit_xushu3;YY3=hilbert(XX3);YY3=imag(YY3);z3=atan(XX3./YY3);Dz3=diff(z3);OM3(iter)=mean(Dz3)/(2*pi);iter=iter+1;end%%绘图区figure(1)mm=0:0.001:0.1;         %%画图所需对应x轴subplot(3,1,1);plot(mm,P(1,:),&#39;b*-&#39;);hold on;plot(mm,P(2,:),&#39;g*-&#39;);hold on;plot(mm,P(3,:),&#39;r*-&#39;);hold on;plot(mm,P(4,:),&#39;c*-&#39;);hold on;plot(mm,P(5,:),&#39;m*-&#39;);hold on;plot(mm,P(6,:),&#39;y*-&#39;);hold on;plot(mm,P(7,:),&#39;k*-&#39;);hold on;plot(mm,P(8,:),&#39;w*-&#39;);hold off;ylabel(&#39;f(π_i)&#39;);% h1=legend(&#39;π_1&#39;,&#39;π_2&#39;,&#39;π_3&#39;,&#39;π_4&#39;,&#39;π_5&#39;,&#39;π_6&#39;,&#39;π_7&#39;,&#39;π_8&#39;);% set(h1,&#39;Orientation&#39;,&#39;horizon&#39;);% set(h1,&#39;Box&#39;,&#39;off&#39;);subplot(3,1,2);[AX,H1,H2]=plotyy(mm,Ho,mm,HT,&#39;plot&#39;);     %%设置双坐标HH1=get(AX(1),&#39;Ylabel&#39;);set(HH1,&#39;String&#39;,&#39;H_o&#39;);HH2=get(AX(2),&#39;Ylabel&#39;);set(HH2,&#39;String&#39;,&#39;H_T&#39;);subplot(3,1,3)plot(mm,OM1,&#39;r&#39;);hold on;plot(mm,OM2,&#39;b&#39;);hold on;plot(mm,OM3,&#39;g&#39;);hold on;xlabel(&#39;k&#39;);ylabel(&#39;Ω_i&#39;);toc%由公式（8）所得函数function f=f_dx1(x,y,z,xx)    %%对dx1/dt,global w1global KLf=-w1*y-z+KL*(xx-x);endfunction f=f_dx3(x,y,z,xx)     %%dx3/dtglobal w3global KLf=-w3*y-z+KL*(xx-x);endfunction f=f_dx2(x,y,z,xx)       %%dx2/dtglobal w2global KLf=-w2*y-z+KL*(xx-2*x);endfunction f=f_dy1(x,y)            %%dy1/dtglobal w1global af=w1*x+a*y;endfunction f=f_dy2(x,y)           %%dy2/dtglobal w2global af=w2*x+a*y;endfunction f=f_dy3(x,y)           %%dy3/dtglobal w3global af=w3*x+a*y;endfunction f=f_dz(x,z)            %%dz/dtf=0.4+z*(x-8.5);end</code></pre><p>结果如下：</p><p>与原文献有较大的差异，或许是此处的代码编写有误。</p><hr><p><strong><u>结论</u></strong></p><p>在这项工作中，我们提出了从多元时间序列构建有序分区转换网络，这有助于我们分析不同组件之间的交互模式。 基本思想是捕获相关速度空间中变化的方向，从而在原始相空间中产生动态信息，而不是静态信息。 所得的有序分区转换网络是加权有向网络，从根本上来说，它们与递归网络 <strong>[19]</strong> 和可见性图 <strong>[10]</strong>  不同。 对于来自离散和连续动力系统的时间序列，我们发现观察到的序数模式的频率是不均匀的，这由熵HO来量化。 另外，不同序数模式之间的过渡频率也是不均匀的，其特征在于熵HT。 请注意，对于离散系统，HO和HT之间不会有本质区别，但是对于连续系统，HT是表征有序分区转换网络的更好方法，因为HO受自环的影响更大，如图 <strong>[4]</strong> 所示。</p><p>​        顺序分区转换网络利用零折线生成分区，从而在相空间中生成时间序列的马尔可夫链表示。 两个序数模式之间的过渡取决于变量增量的符号变化。 正如我们在混沌Rössler系统中所证明的那样，此定义对于捕获相空间的几何变化非常敏感，例如从相干到非相干过渡。</p><p>​        请注意，我们的序数分区过渡网络生成算法与最近构建时空网络以捕获内存效应的工作不同 <strong>[50]</strong> 。 通过顺序分区转换网络来表征存储效应将是未来的课题。 另外，我们集中于每个变量的嵌入维Dx = 2和延迟τ= 1，它捕获了不同空间中时间序列的上升或下降趋势。 可以肯定地将算法推广到更高的Dx和τ值，但是，对计算的要求更高。 例如，在n维多元序列[{x1}（t），…，{xn}（t）]中，如果D. {x1} = … =，则有（3！）^ n个序数模式。  D. {xn} = 3。 另外，转移矩阵W的尺寸为（3！）^n× （3！）^n。 同时，尺寸Dx的增加需要更长的时间序列，以便更可靠地估计顺序图案的转变频率。 从算法的角度来看，通过使用较大的时间延迟τ&gt; 1不会引入任何计算复杂性，但是，对于变量的速度缺乏适当的解释。 从短时间序列可靠地估计序数分区转换矩阵存在一个未解决的问题，尤其是在噪声起重要作用的情况下。</p><hr><p>page eleven</p><p><img src="https://img-blog.csdnimg.cn/20210129162200657.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RhROZXUy-1611895510094)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110163324877.png)]"></p><p>图9.公式 <strong>（8）</strong> 的相位同步路径上的顺序转换网络，为三种典型的耦合强度。  （a）非同步状态下κ= 0.02 &lt;κc1的随机跃迁，（b）主导结构出现在振荡器k = 1和k = 2是相位同步的状态下，但不与k = 3，κ= 0.06  ∈[κc1，κc2]，（c）当所有三个振荡器都被锁相时，仅观察到一种序数模式的跃迁路径，κ= 0.08&gt;κc2。<br>链接的粗细由过渡网络中的相关频率确定，并且消除了自环。 在（a，b）中，为便于可视化，链接箭头被抑制。</p><p>………………………………………………………………………………………………………………………………………</p><p>我们已经应用了序数分区过渡网络来研究相位同步的路径，表明当耦合强度随着不同的同步过渡机制而增加时，网络中会出现主导过渡路径。 随着同步程度的提高，耦合系统的动力学特性被锁定到同步歧管，从而在最终的顺序分区网络中产生主导过渡路径。 在出现同步之前，另一项艰巨的任务是区分间接耦合方向和直接耦合方向 <strong>[49、51]</strong> ，这在气候数据分析中非常常见，即从远处的多通道时间序列中提取网络交互模式 <strong>[52]</strong> 。 在我们考虑的三个耦合Rössler子系统的情况下（公式 <strong>（8）</strong> ），振荡器k = 2双向耦合到k = 1和k = 3，而在k = 1和k =3之间没有直接耦合。   可以引入有序递归图 <strong>[45]</strong> 来解决此问题。</p><p>​        传统上，基于时间序列的序数符号表示的置换熵的计算不包括遵循相空间轨迹的模式转换行为。 相反，有序分区过渡网络方法明确考虑了时间演化信息，因此为传统的符号分析提供了很多补充性见解，显示了进行实验时间序列分析的巨大潜力。</p><p><strong><u>方法：相干指数</u></strong></p><p>在这里，我们总结了参考文献中计算相位相干指数的主要步骤。**[48]** .我们在这项工作中的注意力仅限于标准分析信号方法。 在此，使用希尔伯特变换将标量信号x（t）扩展到复平面</p><p><img src="https://img-blog.csdnimg.cn/20210129162216703.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yh0Fs81b-1611895510097)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110164213051.png)]"></p><p>P.V. 表示柯西积分的主值，产生相位</p><p><img src="https://img-blog.csdnimg.cn/20210129162228209.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-81yzzRha-1611895510098)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110164255400.png)]"></p><p>上面的定义对于相位相干动力学很简单。 在非相位相干动力学中，基于解析信号53的局部曲率特性，提出了另一种相位定义 <strong>[53]</strong> ，即</p><p><img src="https://img-blog.csdnimg.cn/20210129162245465.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cFL41bJh-1611895510099)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110164355843.png)]"></p><p>由于在基于Hilbert变换的标准定义中，相位变量φ（t）不一定会随时间单调增加，因此我们对这种单调性进行了量化，以便获得用于相位相干的简单启发式阶参数，我们将其称为相干 指数</p><p><img src="https://img-blog.csdnimg.cn/20210129162302281.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5MGZpo57-1611895510100)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110164443647.png)]"></p><p>φ（t）=dφ（t）/ dt。 此外，然后将混沌振荡器的瞬时频率定义为相位变量相对于时间的导数。 随时间平均该属性可得出平均频率</p><p><img src="https://img-blog.csdnimg.cn/20210129162317887.jpg#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UwgcEhL2-1611895510101)(C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210110164619471.png)]"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 复杂网络研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元时间序列转化为网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用Python绘制雷达图时遇到的坑</title>
      <link href="/2021/060663202.html"/>
      <url>/2021/060663202.html</url>
      
        <content type="html"><![CDATA[<p>ValueError: The number of FixedLocator locations (9), usually from a call to set_ticks, does not match the number of ticklabels (8).</p><p>运行书中例题时发现了这个错误，<br>原代码如上：</p><pre><code class="c">import numpy as npimport matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#39;font.family&#39;]=&#39;simhei&#39;# 某学生的课程与成绩courses = np.array([&#39;C++&#39;,&#39;Python&#39;,&#39;高数&#39;,&#39;大学英语&#39;,&#39;软件工程&#39;,           &#39;组成原理&#39;,&#39;数字图像处理&#39;,&#39;计算机图形学&#39;])scores=np.array([80,95,78,85,45,65,80,60])datalength = len(scores)     #数据长度# angles数组把圆周等分为dataLength份angles = np.linspace(0,         #数组第一个数据                    2*np.pi,    #数组最后一个暑假                    datalength, #数组中的数据量                    endpoint=False) #不包含终点scores = np.concatenate((scores,[scores[0]]))angles = np.concatenate((angles,[angles[0]]))# 绘制雷达图print(angles)print(&#39;=&#39;*20)print(scores)plt.polar(angles,          scores,          &#39;rv--&#39;,          linewidth=2)# 设置角度网络标签plt.thetagrids(angles*180/np.pi,courses)# 填充雷达图内部plt.fill(angles,scores,facecolor=&#39;r&#39;,alpha=0.6)plt.show()</code></pre><p><img src="https://img-blog.csdnimg.cn/20210417214433910.png" alt="在这里插入图片描述"><br>自己搜查资料后，了解到，只对socres，和angles做闭合还是不够</p><p>需要再对courses进行闭合</p><pre><code>courses = np.concatenate((courses,[courses[0]]))</code></pre><p><img src="https://img-blog.csdnimg.cn/20210417214555187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时就能正确运行出来。</p><hr><p>这里在附上霍兰德人格分析代码：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#39;font.family&#39;]=&quot;SimHei&quot;radar_labels = np.array([&#39;研究型（I）&#39;,&#39;艺术型（A）&#39;,&#39;社会型（S）&#39;,\                        &#39;企业型（E）&#39;,&#39;常规型（C）&#39;,&#39;现实型（R）&#39;])data = np.array([[0.40, 0.32, 0.35, 0.30, 0.30, 0.88],                 [0.85, 0.35, 0.30, 0.40, 0.40, 0.30],                 [0.43, 0.89, 0.30, 0.28, 0.22, 0.30],                 [0.30, 0.25, 0.48, 0.85, 0.45, 0.40],                 [0.20, 0.38, 0.87, 0.45, 0.32, 0.28],                 [0.34, 0.31, 0.38, 0.40, 0.92, 0.28]])data_labels =(&#39;艺术家&#39;,&#39;实验员&#39;,&#39;工程师&#39;,&#39;推销员&#39;,&#39;社会工作者&#39;,&#39;记事员&#39;)angles = np.linspace(0, 2*np.pi, 6, endpoint=False)fig = plt.figure(facecolor = &quot;white&quot;)plt.subplot(111, polar = True)plt.plot(angles, data,&#39;o-&#39;,linewidth=1, alpha=0.2)plt.fill(angles, data, alpha=0.25)plt.thetagrids(angles*180/np.pi, radar_labels)plt.figtext(0.52, 0.95, &#39;霍兰德人格分析&#39;, ha=&#39;center&#39;, size=20)legend = plt.legend(data_labels, loc = (0.94, 0.80), labelspacing = 0.1)plt.setp(legend.get_texts(), fontsize=&#39;large&#39;)plt.grid(True)plt.savefig(&#39;holland_radar.jpg&#39;)plt.show()</code></pre><p><img src="https://img-blog.csdnimg.cn/20210417214755175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雷达图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL镜像下载及启动</title>
      <link href="/2021/060649492.html"/>
      <url>/2021/060649492.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL安装"><a href="#1-MySQL安装" class="headerlink" title="1.MySQL安装"></a>1.MySQL安装</h1><p>官网下载的MySQL实在太慢了， 这里添上<a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-8.0/">清华大学的MySQL镜像网址</a><br><code>Ctrl+F</code>根据自己电脑版本搜索，这里我是windows64位的<br><img src="https://img-blog.csdnimg.cn/20210523194538248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210523200201261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用管理员身份启动命令行窗口<br><img src="https://img-blog.csdnimg.cn/20210523213330890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我把MySQL安装在了E:\mysql-8.0.23-winx64，在命令行窗口进入MySQL安装目录的bin子目录下</p><p><img src="https://img-blog.csdnimg.cn/20210523213622701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入<code>mysqld --initialize</code><br><img src="https://img-blog.csdnimg.cn/2021052321375539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>执行成功后,MySQ安装目录下多出一个data子目录（用于存放数据库），data子目录下找到.err文件<br><img src="https://img-blog.csdnimg.cn/20210523214021759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>A temporary password is generated for root@localhost：密码</code><br>此时可看出,root的临时密码是：N-a3gSyj:tC;</p><p>输入<code>net start mysql</code>启动MySQL服务器<br><img src="https://img-blog.csdnimg.cn/20210523214353681.png" alt="在这里插入图片描述"><br>输入<code>mysqladmin -u root -p password</code>命令确认root用户和root用户的密码。或确认root用户，并修改root用户的密码<br><img src="https://img-blog.csdnimg.cn/20210523214654129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Enter password：N-a3gSyj:tC;<br>另外，自己可以另外设置新的密码了。</p><p><img src="https://img-blog.csdnimg.cn/20210523214943303.jpg#pic_center" alt="在这里插入图片描述"></p><h1 id="2-启动MySQL"><a href="#2-启动MySQL" class="headerlink" title="2.启动MySQL"></a>2.启动MySQL</h1><p>现在，我们来启动MySQL命令行客户端。<br>在MySQL安装目录下的bin子目录，cmd打开新的命令行窗口(不必管理员身份啦)，输入<code>mysql -u root -p</code><br>在输入密码后即进进入mysql<br><img src="https://img-blog.csdnimg.cn/20210523215236723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在，我们来进行一些基本的数据库操作！！！</p><p>创建数据库<code>create database bookDatabase</code><br><img src="https://img-blog.csdnimg.cn/20210523215628634.png" alt="在这里插入图片描述"><br>如果数据库已经存在,将提示数据库已经存在，不再创建数据库，否则将创建数据库，如果删除已有数据库，例如bookDatabase；执行语句<code>drop database bookDatabase;</code></p><p>在数据库内建表<br>命令格式为：use 数据库名;<br>分号此时可加可不加<br><img src="https://img-blog.csdnimg.cn/20210523220118361.png" alt="在这里插入图片描述"><br>下面在数据库bookDatabase建立一个名字为bookList表<br>输入</p><pre><code>create table bookList(ISBN varchar(100) not null,name varchar(100) character set gb2312,price float,publishData date,primary key(ISBN));</code></pre><p><img src="https://img-blog.csdnimg.cn/20210523220450893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将数据插入表格中.</p><pre><code>insert into bookList values(&#39;7302014655&#39;,&#39;高等数学&#39;,28.67,&#39;2020-12-10&#39;),(&#39;7352014658&#39;,&#39;大学英语&#39;,58.5,&#39;1999-9-10&#39;),(&#39;7987302464259&#39;,&#39;Java2实用教材第5版&#39;,59.5,&#39;2017-5-1&#39;);</code></pre><p><img src="https://img-blog.csdnimg.cn/20210523220811987.png" alt="在这里插入图片描述"><br>查询bookList表中的所有记录</p><pre><code>select * from bookList;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210523220914974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="3-安装时遇到的问题（已解决）"><a href="#3-安装时遇到的问题（已解决）" class="headerlink" title="3.安装时遇到的问题（已解决）"></a>3.安装时遇到的问题（已解决）</h1><h2 id="3-1Mysql安装时mysqld-exe报应用程序无法正常启动-0xc000007b-的问题"><a href="#3-1Mysql安装时mysqld-exe报应用程序无法正常启动-0xc000007b-的问题" class="headerlink" title="3.1Mysql安装时mysqld.exe报应用程序无法正常启动(0xc000007b)的问题"></a>3.1<a href="https://blog.csdn.net/mynameisgt/article/details/117201946">Mysql安装时mysqld.exe报<code>应用程序无法正常启动(0xc000007b)</code>的问题</a></h2><h2 id="3-2cmd无法启动mysql-cmd-显示服务名无效"><a href="#3-2cmd无法启动mysql-cmd-显示服务名无效" class="headerlink" title="3.2cmd无法启动mysql cmd 显示服务名无效"></a>3.2<a href="https://blog.csdn.net/mynameisgt/article/details/117201836">cmd无法启动mysql cmd 显示服务名无效</a></h2>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL的安装及启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用Git向GitHub上传送文件(从注册GitHub到用Git上传的每一步)</title>
      <link href="/2021/060627056.html"/>
      <url>/2021/060627056.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-GitHub"><a href="#1-GitHub" class="headerlink" title="1.GitHub"></a>1.GitHub</h1><h2 id="1-1-GitHub注册（已经注册过的直接看1-2GitHub仓库的建立）"><a href="#1-1-GitHub注册（已经注册过的直接看1-2GitHub仓库的建立）" class="headerlink" title="1.1.GitHub注册（已经注册过的直接看1.2GitHub仓库的建立）"></a>1.1.GitHub注册（已经注册过的直接看1.2GitHub仓库的建立）</h2><p>第一步：网上搜索GitHub,找到这个界面，点击Sign up进行注册<br><img src="https://img-blog.csdnimg.cn/20210520092920145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第二步：输入基本信息，包括GitHub账号，一个用来接收消息的邮箱，GitHub的密码<br><img src="https://img-blog.csdnimg.cn/20210520094959405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第三步：这里打勾，GitHub用来给你推送你感兴趣的内容，可跳过<br><img src="https://img-blog.csdnimg.cn/20210520095237748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第四步：邮箱验证<br>当你完成以上步骤，Github将会往你的邮箱发送一封信件，点击Verify email address后，你的GitHub也就注册完成了<br><img src="https://img-blog.csdnimg.cn/20210520095409337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第五：GitHub注册完成<br>在这里，我们跳过就行了。接下来，我们登陆GitHub，在GitHub上开启我们的接下来的旅程<br><img src="https://img-blog.csdnimg.cn/20210520095646793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-2-GitHub仓库的建立"><a href="#1-2-GitHub仓库的建立" class="headerlink" title="1.2 GitHub仓库的建立"></a>1.2 GitHub仓库的建立</h2><p>第一步 登陆GitHub<br><img src="https://img-blog.csdnimg.cn/20210520100228133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210520100635369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第二步：建立一个仓库<br><img src="https://img-blog.csdnimg.cn/20210520100818720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210520101419577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>到这里我们的仓库已经建立完毕，<br><img src="https://img-blog.csdnimg.cn/20210520101512353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第三步：可以的话，先把仓库主分支的名字(main)改成master<br><img src="https://img-blog.csdnimg.cn/20210520101923236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210520101945701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210520102027553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210520102130959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>完成已上步骤，接下来我们需要用Git把文件上传到GitHub上。我们知道GitHub是基于Git上传的</p><h1 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h1><h2 id="2-1Git-安装"><a href="#2-1Git-安装" class="headerlink" title="2.1Git 安装"></a>2.1Git 安装</h2><p>点击这里进入<a href="https://git-scm.com/">Git官网</a><br>第一步：<br><img src="https://img-blog.csdnimg.cn/20210520102721740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我这电脑是Windows64位<br><img src="https://img-blog.csdnimg.cn/20210520102832753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点开这里，网页会自动根据你电脑的版本下载Git，这里下载比较慢，可以用国内镜像文件快速下载（这里我就不赘述了）<br><img src="https://img-blog.csdnimg.cn/20210520103350887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-2-Git-下载"><a href="#2-2-Git-下载" class="headerlink" title="2.2 Git 下载"></a>2.2 Git 下载</h2><p><img src="https://img-blog.csdnimg.cn/20210520104752761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210520104840601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>默认即可。<br><img src="https://img-blog.csdnimg.cn/20210520104910605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>默认，next<br><img src="https://img-blog.csdnimg.cn/20210520104946923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>后面一直默认,next即可</p><h2 id="2-3-Git-初探"><a href="#2-3-Git-初探" class="headerlink" title="2.3 Git 初探"></a>2.3 Git 初探</h2><p>在桌面新建一个文件夹，对该文件夹右键，选择Git Bush Here<br><img src="https://img-blog.csdnimg.cn/20210520112411371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们先设置一些 Git用户的名字和邮箱，这是必须要填的，这样上传后才知道是谁上传的，一般我们都是设置全局的名字和邮箱。</p><pre><code>git config --global user.name &quot;名字&quot;git config --global user.email &quot;邮箱&quot;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210520112837201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210520112945398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>进行到这里，我们会发现我们电脑多了两个文件.gitconfig和.bash_history。</p><ul><li>gitconfig：存储了全局变量姓名和邮箱</li><li>bash_history：存储了历史的 git命令语句</li></ul><h2 id="2-4-Git-基本命令语句"><a href="#2-4-Git-基本命令语句" class="headerlink" title="2.4 Git 基本命令语句"></a>2.4 Git 基本命令语句</h2><p>这里是<a href="https://www.runoob.com/git/git-basic-operations.html">git 基本操作</a>。当然，后面我们在和GitHub连接时会介绍一些语句的具体用法</p><h1 id="3-Git与GitHub进行交互"><a href="#3-Git与GitHub进行交互" class="headerlink" title="3 Git与GitHub进行交互"></a>3 Git与GitHub进行交互</h1><h2 id="3-1-SSH完成Git与GitHub的绑定"><a href="#3-1-SSH完成Git与GitHub的绑定" class="headerlink" title="3.1 SSH完成Git与GitHub的绑定"></a>3.1 SSH完成Git与GitHub的绑定</h2><p>现在我们需要将Git和GitHub通过进行绑定，这样就可以通过Git向GitHub发送文件了。一般我们都是通过SSH公钥来授权的<br>在Git Bash 输入<strong>ssh</strong>可查看本机是否安装了SSH：<br><img src="https://img-blog.csdnimg.cn/20210520113536161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们下载Git时，会顺带安装SSH，如上图所示，我们已经成功安装了SSH，接下来我们就可需要通过RSA算法生成密钥：</p><pre><code>ssh-keygen -t rsa</code></pre><p><img src="https://img-blog.csdnimg.cn/20210520113918208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入完ssh-keygen -t rsa后一路回车就可以了，此时已经生成了SSH密钥<br>我们找到<br><img src="https://img-blog.csdnimg.cn/20210520114110753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于id_rsa.pub上的信息进行复制,将上述信息存放到GitHub的SSH密钥上面</p><p>接下来打开对GitHub<br><img src="https://img-blog.csdnimg.cn/20210520114432278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210520114510618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210520114543537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一般到这里会验证确认是否为本人操作<br><img src="https://img-blog.csdnimg.cn/20210520114557990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>OK，到这里，我们已经将SSH密钥绑定上了。</p><h2 id="3-2将文件提交到GitHub上"><a href="#3-2将文件提交到GitHub上" class="headerlink" title="3.2将文件提交到GitHub上"></a>3.2将文件提交到GitHub上</h2><p>我们先获取仓库地址<br><img src="https://img-blog.csdnimg.cn/20210520115821716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过git clone 地址会自动将git和GitHunb连接在一起，首先我们还是在桌面上的一个新建文件夹进行操作。<br><img src="https://img-blog.csdnimg.cn/20210520120052735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>git clone 地址</code></pre><p><img src="https://img-blog.csdnimg.cn/2021052012015232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们发现文件夹内把GitHub的仓库example1的文件给下载下来了。接下来，我们要上传一个文件到GitHub上，我在此新建一个test.txt<br><img src="https://img-blog.csdnimg.cn/20210520120801956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们在把test.txt给放入example1文件夹内<br>在用 <code>cd example1 </code>进入到exampl1的文件内<br><img src="https://img-blog.csdnimg.cn/20210520121006201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们输入 <code>git status </code><br><img src="https://img-blog.csdnimg.cn/20210520121036728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>test.txt可添加。<br>输入<code>git add .</code><br><img src="https://img-blog.csdnimg.cn/20210520121145576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入<code>git add . </code>之后，我们在git status发现了新文件 test.txt,在进行操作<br><code>git commit -m &quot;注释&quot;</code><br><img src="https://img-blog.csdnimg.cn/20210520121519420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来，我们需要把该文件推送到GitHub上了<br><code>git push -u origin master</code><br><img src="https://img-blog.csdnimg.cn/20210520130105398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>正常的输入GitHub的账号和密码即可<br><img src="https://img-blog.csdnimg.cn/20210520130455724.png" alt="在这里插入图片描述"><br>GitHub刷新一下，就发现文件已经进去了<br><img src="https://img-blog.csdnimg.cn/20210520130508450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github的应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习（周志华）——决策树问题</title>
      <link href="/2021/06061837.html"/>
      <url>/2021/06061837.html</url>
      
        <content type="html"><![CDATA[<p>matlab算法实现：</p><pre><code class="c">clear;clcdata=[-1 0 0 -1 1 -1 0 0 0 -1 1 1 -1 1 0 1 -1;    -1 -1 -1 -1 -1 0 0 0 0 1 1 -1 0 0 0 -1 -1;    -1 0 -1 0 -1 -1 -1 -1 0 1 1 -1 -1 0 -1 -1 1;    -1 -1 -1 -1 -1 -1 0 -1 0 -1 1 1 0 0 -1 1 0;    -1 -1 -1 -1 -1 0 0 0 0 1 1 1 -1 -1 0 1 0;    -1 -1 -1 -1 -1 1 1 -1 -1 1 -1 1 -1 -1 1 -1 -1]&#39;;y=[1 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 -1 -1]&#39;;%算法的实例[m,n]=size(data);for j=1:n    %计算根节点的信息熵    v_0 = tabulate(y);    p1 = v_0(1,end)/100;    p2 = v_0(2,end)/100;    Ent_D = -(p1*log2(p1)+p2*log2(p2));        %获取每个属性集的信息增益    v_1 = tabulate(data(:,j));    [m1,n1] = size(v_1);    D_P = v_1(:,end)/100;    Ent_D_k=zeros(m1,1);    for i=1:m1        k = find(data(:,j)==v_1(i,1));        P(i) = sum(y(k)==1)/length(k);        if P(i)~= 0 &amp;&amp; P(i) ~=1            Ent_D_k(i) = -(P(i)*log2(P(i))+(1-P(i))*log2(1-P(i)));        end    end        Gain_D(j) = Ent_D-D_P&#39;*Ent_D_k;endGain_D</code></pre><p><img src="https://img-blog.csdnimg.cn/20210328143151947.png" alt="在这里插入图片描述"><br>划分决策树Python</p><pre><code class="c">###以西瓜书76为例决策树import pandas as pdimport numpy as npimport mathimport copydata = pd.read_excel(&#39;watermelon20.xlsx&#39;)#data.isnull().sum()#根节点#y = data[&#39;好瓜&#39;].value_counts().shape[0]#计算信息熵def Information_Entropy(plist):    ent = 0    for p in plist:        ent += p*math.log(p,2)    ent = -ent    return entdef get_p(feature,data):    idx = data[feature].value_counts().index.tolist()    val = data[feature].value_counts().tolist()    sum_val = sum(val)    plist = []    for i in val:        plist.append(i/sum_val)    return idx,plist####属性的信息增益def Decision_Tree(data,root_node,old_features_list,entD,flag=0):    #data:根节点未划分的数据    #root_node:根节点    #feature:当前属性集合（分支节点）    #entD:根节点的信息熵    #example for西瓜数据集2.0:    #对于初始时，data为整个数据集，root_node为好瓜，feature为要考察的属性（分支节点）,entD为好瓜坏瓜信息熵#        total_num = data.shape[0]##根节点D的样本个数        print(&#39;--------------------------------&#39;)    print(&#39;输入根节点:&#39;,root_node)    print(&#39;取值:&#39;,data[root_node].values[0])    flag +=1    if len(old_features_list) == 0:        return     if entD==0:        print(&#39;结论：坏瓜!&#39;) if data[&#39;好瓜&#39;].values[0]==&#39;否&#39; else print(&#39;结论：好瓜!&#39;)        print(&#39;--------------------------------&#39;)        return    gain_step1 = []    ent_whole_step1 = []    ent_whole_name = []        #注意：如果直接将features_list输出，那么在这个分支remove了这个属性，对于其他分支也无法使用，将产生错误影响!!!!    #因此输出和输入不是同一个列表!!!!!        features_list = copy.deepcopy(old_features_list)#    features_list = old_features_list    for feature in features_list: #对于不同属性        grouped = data.groupby(feature)        fe = data[feature].value_counts().index.tolist()#        print(fe)        subclass = []        for f in fe:            subclass.append(grouped.get_group(f))#按分支节点划分子类        idx,plist = [],[]        sub_num = []##每个子类的样本个数        for sub in subclass:            i,p = get_p(&#39;好瓜&#39;,sub) #计算每个子类好坏瓜的概率            idx.append(i)            plist.append(p)            sub_num.append(sub.shape[0])##每个子类的样本个数        ##多个分支节点的信息熵        ent_whole = []          for per_plist in plist:            per_ent = Information_Entropy(per_plist)            ent_whole.append(per_ent)                    gain_step1.append(get_Gain(sub_num,ent_whole,entD))  #每个属性的信息增益,每个属性一个数          ent_whole_step1.append(ent_whole)          #这个属性几个子类的信息熵        ent_whole_name.append(fe)                  #这个属性几个子类的信息熵对应的名字，如‘清晰’                print(&#39;属性:&#39;,feature,&#39;增益:&#39;,get_Gain(sub_num,ent_whole,entD))   #####找到信息增益最大的，选为划分属性    idmax = gain_step1.index(max(gain_step1))       root_node = features_list[idmax]  ##新的根节点“纹理”      entD = ent_whole_step1[idmax]    entD_name = ent_whole_name[idmax]    re1 = save_re(features_list,gain_step1)    re1.to_excel(str(flag)+&#39;.xlsx&#39;)    print(&#39;产生新的节点:&#39;,root_node,&#39;下一阶段可取值:&#39;,entD_name)    print(&#39;--------------------------------&#39;)        features_list.remove(root_node)  ##属性中 去除新的根节点        die_data = data.groupby(root_node)    #    new_depart = data[root_node].value_counts().index.tolist()#    for i in range(len(new_depart)):#        print(&#39;根节点:&#39;,root_node,&#39;------------&#39;,&#39;取值:&#39;,new_depart)#        Decision_Tree(die_data.get_group(new_depart[i]),root_node,features_list,entD[i],flag)    return die_data,root_node,features_list,entD,entD_name        #        ent_whole_2 = ent_whole_step1[idmax]        def get_Gain(sub_num,ent_whole,entD):##信息增益    add = 0    total_num = sum(sub_num)    for i in range(len(ent_whole)):        add += (sub_num[i]/total_num)*ent_whole[i]    return entD - add#        Gain = get_Gain(sub_num,ent_whole,entD)        ##保存每个属性的增益结果def save_re(features_list,gain_step):    features_listcp,gain_stepcp = features_list.copy(),gain_step.copy()    features_listcp = np.array(features_listcp)    gain_stepcp = np.array(gain_step)        re = np.hstack((features_listcp.reshape((features_listcp.shape[0],1)),gain_stepcp.reshape((features_listcp.shape[0],1))))    return pd.DataFrame(re,columns=[&#39;属性&#39;,&#39;信息增益&#39;])        ##以好瓜为根节点，计算各个属性的信息增益features_list = [&#39;色泽&#39;,&#39;根蒂&#39;,&#39;敲声&#39;,&#39;纹理&#39;,&#39;脐部&#39;,&#39;触感&#39;]root_node = &#39;好瓜&#39;idx,plist = get_p(&#39;好瓜&#39;,data)entD = Information_Entropy(plist)##############print(&#39;第0层&#39;)##根节点为好瓜die_data,root_node,fl,entD1,entDname1 = Decision_Tree(data,root_node,features_list,entD)###############print(&#39;第1层&#39;)##根节点为纹理node1 = Decision_Tree(die_data.get_group(entDname1[0]),root_node,fl,entD1[0])node2 = Decision_Tree(die_data.get_group(entDname1[1]),root_node,fl,entD1[1])node3 = Decision_Tree(die_data.get_group(entDname1[2]),root_node,fl,entD1[2])################print(&#39;第2层&#39;)#根节点为根蒂node11 = Decision_Tree(node1[0].get_group(node1[4][0]),node1[1],node1[2],node1[3][0])node12 = Decision_Tree(node1[0].get_group(node1[4][1]),node1[1],node1[2],node1[3][1])node13 = Decision_Tree(node1[0].get_group(node1[4][2]),node1[1],node1[2],node1[3][2])##根节点为触感node21 = Decision_Tree(node2[0].get_group(node2[4][0]),node2[1],node2[2],node2[3][0])node22 = Decision_Tree(node2[0].get_group(node2[4][1]),node2[1],node2[2],node2[3][1])################print(&#39;第3层&#39;)node31 = Decision_Tree(node12[0].get_group(node12[4][0]),node12[1],node12[2],node12[3][0])node32 = Decision_Tree(node12[0].get_group(node12[4][1]),node12[1],node12[2],node12[3][1])################print(&#39;第4层&#39;)node41 = Decision_Tree(node31[0].get_group(node31[4][0]),node31[1],node31[2],node31[3][0])node41 = Decision_Tree(node31[0].get_group(node31[4][1]),node31[1],node31[2],node31[3][1])#</code></pre><p><img src="https://img-blog.csdnimg.cn/20210405155824697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 决策树问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习（周志华）——对数几率回归</title>
      <link href="/2021/060624057.html"/>
      <url>/2021/060624057.html</url>
      
        <content type="html"><![CDATA[<p>课后习题3.3,编程实现对率回归，并给出西瓜数据集3.0$\ a$上的结果<br><img src="https://img-blog.csdnimg.cn/2021032118535032.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210321185604406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210321190110836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>由公式（3.23）、（3.29）、（3.30）、（3.31）进行公式带入，</p><p>实现matlab的算法如下：</p><pre><code class="c">clear;clctic%初始数据集x=[0.697 0.460    0.774 0.376    0.634 0.264    0.608 0.318    0.556 0.215    0.403 0.237    0.481 0.149    0.437 0.211    0.666 0.091    0.243 0.267    0.245 0.057    0.343 0.099    0.639 0.161    0.657 0.198    0.360 0.370    0.593 0.042    0.719 0.103];y=[1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0]&#39;;%%对率回归的实现%前期数据处理x=[x ones(length(x),1)];beta=ones(1,size(x,2));   %设定beta的初始值n=1000;                  %设定迭代次数%算法实现for k=1:n    B1=0;    for i=1:length(x)        B1=B1-x(i,:)*(y(i)-func_sigmod(beta,x(i,:)));    end    B2=0;    for i=1:length(x)        B2=B2+sum(x(i,:).^2)*func_sigmod(beta,x(i,:))*(1-func_sigmod(beta,x(i,:)));    end    beta=beta-1/B2*B1;endbetatocfunction y=func_sigmod(beta,x0)y=exp(sum(beta.*x0))/(1+exp(sum(beta.*x0)));end</code></pre><p><img src="https://img-blog.csdnimg.cn/20210321190046966.png" alt="在这里插入图片描述"><br>Python代码实现效果如下：</p><pre><code class="c">import numpy as npimport mathx=np.array([[0.697,0.460],[0.774,0.376],[0.634,0.264],[0.608,0.318],[0.556,0.215],[0.403,0.237],[0.481,0.149],[0.437,0.211],[0.666,0.091],            [0.243,0.267],[0.245,0.057],[0.343,0.099],[0.639,0.161],[0.657,0.198],[0.360,0.370],[0.591,0.042],[0.719,0.103]])y=np.array([1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0])##对率回归的实现#前期数据处理ones1=np.array([[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]])ones1=ones1.Tx1=np.concatenate((x,ones1),axis=1)beta=np.array([1,1,1])    #设定beta的初始值n=1000;                   #设定迭代次数def func_sigmod(beta,x0):    y = math.exp(np.dot(beta,x0))/(1+math.exp(np.dot(beta,x0)))    return y#算法实现for k in range(0,n):    B1=0    for j in range(len(x)):        B1=B1-x1[j,:]*(y[j]-func_sigmod(beta,x1[j,:]))    B2=0    for j in range(len(x)):        B2=B2+(x1[j,:]**2).sum()*func_sigmod(beta,x1[j,:])*(1-func_sigmod(beta,x1[j,:]))    beta=beta-1/B2*B1print(beta)</code></pre><p><img src="https://img-blog.csdnimg.cn/20210325204713736.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对数几率回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类性能度量指标及距离计算</title>
      <link href="/2021/060658520.html"/>
      <url>/2021/060658520.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-外部指标"><a href="#1-外部指标" class="headerlink" title="1.外部指标"></a>1.外部指标</h1><pre><code>将聚类结果与某个“参考模型进行比较”</code></pre><p>每次抽出两个样本，讨论所属聚类结果和参考模型，确定四个值：</p><ul><li>a:聚类结果同属于一类，参考模型同属于一类</li><li>b:聚类结果同属于一类，参考模型<strong>不</strong>同属于一类</li><li>c:聚类结果<strong>不</strong>同属于一类，参考模型属于同一类</li><li>d:聚类结果<strong>不</strong>同属于一类，参考模型<strong>不</strong>同属于一类</li></ul><h2 id="1-1Jaccard系数（JC）"><a href="#1-1Jaccard系数（JC）" class="headerlink" title="1.1Jaccard系数（JC）"></a>1.1Jaccard系数（JC）</h2><p>$$<br>JC=\frac{a}{a+b+c}<br>$$</p><h2 id="1-2FM指数（FMI）"><a href="#1-2FM指数（FMI）" class="headerlink" title="1.2FM指数（FMI）"></a>1.2FM指数（FMI）</h2><p>$$<br>FMI=\sqrt{\frac{a}{a+b}*\frac{a}{a+c}}<br>$$</p><h2 id="1-3Rand指数（RI）"><a href="#1-3Rand指数（RI）" class="headerlink" title="1.3Rand指数（RI）"></a>1.3Rand指数（RI）</h2><p>$$<br>RI=\frac{2(a+d)}{m(m-1)}<br>$$</p><p>上述性能度量的结果值均在[0,1]区间，值越大越好。</p><h1 id="2-内部指标"><a href="#2-内部指标" class="headerlink" title="2.内部指标"></a>2.内部指标</h1><pre><code>直接考察聚类结果而不利用任何参考模型</code></pre><p>将聚类结果的簇划分为$C={C_1,C_2,…,C_k}$,也就是总共划分为k个簇<br>$$<br>avg(C)=\frac{2}{|C|(|C|-1)}\sum_{1\leq i&lt;j\leq|C|}<br>dist(x_i,x_j)<br>$$</p><ul><li>$avg(C)$：对应于簇C内样本间的平均距离</li></ul><p>$$<br>diam(C)=max_{1\leq i&lt;j\leq|C|}dist(x_i,x_j)<br>$$</p><ul><li>$diam(C)$：对应于簇C内样本间的最远距离</li></ul><p>$$<br>d_{min}(C_i,C_j)=min_{x_i\in C_i,x_j\in C_j}dist(x_i,x_j)<br>$$</p><ul><li>$d_{min}(C_i,C_j)$：对应于簇$C_i$与簇$C_j$最近样本间的距离</li></ul><p>$$<br>d_{cen}(C_i,C_j)=dist(u_i,u_j)<br>$$</p><ul><li>$d_{cen}(C_i,C_j)$：对应于簇$C_i$与簇$C_j$中心点间的距离</li></ul><h2 id="2-1DB指数（DBI）"><a href="#2-1DB指数（DBI）" class="headerlink" title="2.1DB指数（DBI）"></a>2.1DB指数（DBI）</h2><p>$$<br>DBI=\frac{1}{k}\sum_{i=1}^{k}max_{j\ne i}(\frac{avg(C_i)+avg(C_j)}{d_{cen}(C_i,C_j)})<br>$$</p><h2 id="2-2Dunn指数（DI）"><a href="#2-2Dunn指数（DI）" class="headerlink" title="2.2Dunn指数（DI）"></a>2.2Dunn指数（DI）</h2><p>$$<br>DI=min_{1\leq i\leq k}{min_{j\ne i}(\frac{d_{min}(C_i,C_j)}{max_{1\le l\le k}diam(C_l))})}<br>$$</p><p>DBI的值越小越好，DI值越大越好.</p><h1 id="3距离计算"><a href="#3距离计算" class="headerlink" title="3距离计算"></a>3距离计算</h1><p>dist(,)若它是一个“距离度量”，则需要满足一些基本性质：</p><ul><li>非负性：$dist(x_i,x_j)\geq0$</li><li>同一性：$dist(x_i,x_j)=0$当且仅当$x_i=x_j$</li><li>对称性：$dist(x_i,x_j)=dist(x_j,x_i)$</li><li>直递性：$dist(x_i,x_j)\le dist(x_i,x_k)+dist(x_k,x_j)$</li></ul><p>给定样本$x_i=(x_{i1};x_{i2};…;x_{in})$与$x_j=(x_{j1};x_{j2};…;x_{jn})$,最常用的是”闵可夫斯基距离”(Minkokski distance)<br>$$<br>dist_{mk}(x_i,x_j)=(\sum_{u=1}^n|x_{iu}-x_{ju}|)^{\frac{1}{p}}<br>$$<br>$p\geq 1$时，满足上述的距离基本性质</p><p>当$p=2$时，闵可夫斯基距离就是我们熟知的欧式距离(Euclidean distance)<br>$$<br>dist_{ed}(x_i,x_j)=||x_i-x_j||<em>2=\sqrt{\sum</em>{u=1}^n|x_{iu}-x_{ju}|^2}<br>$$<br>当$p=1$时,闵可夫斯基距离为曼哈顿距离(Manhattan distance)<br>$$<br>dist_{man}(x_i,x_j)=||x_i-x_j||<em>1=\sum</em>{u=1}^n|x_{iu}-x_{ju}|<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 聚类指标及距离计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准BP算法matlab实现,简单易懂</title>
      <link href="/2021/060650172.html"/>
      <url>/2021/060650172.html</url>
      
        <content type="html"><![CDATA[<p>机器学习的实验课要求自编写一份简易的标准BP（神经网络）算法,我用matlab基本实现了，现将自己的思想记录下来，方便自己以后重温.话不多说，让我们进入正题</p><p><a href="https://blog.csdn.net/mynameisgt/article/details/115579209">调用matlab的神经网络算法解决具体问题&lt;参照我另一篇博客&gt;</a></p><p><a href="https://blog.csdn.net/mynameisgt/article/details/115644410">这里是自己编写的python实现标准BP算法</a><br>@[toc]</p><h3 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h3><p>神经网络中最基本的成分是神经元模型,先简单提一个最简单的神经元模型M-P神经元模型<br><img src="https://img-blog.csdnimg.cn/2021041020141417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>该神经元模型有两层：输入层,输出层。<br>其中输入层包含 <strong>n</strong> 个神经元,输出层包含 <strong>1</strong> 个神经元。<br>输入信号通过连接的权重$w_i$到达输出神经元,总接收的输入值与阀值$\theta$进行比较,然后通过”激活函数”处理以产生神经元的输出。这里介绍一个最具典型的Sigmoid函数</p><p><img src="https://img-blog.csdnimg.cn/20210410202932741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Sigmod函数能把较大范围内变化的输入值积压到(0,1)的输出值范围内,有时也被称为”挤压函数”</p><p>通常情况下,为了处理更加复杂的问题,在输入层与输出层之间会增添多个隐层.常见的神经网络形如下图的层级结构,每层神经元与下层神经元全互连,同层神经元不进行连接,也不存在跨层连接。其中需要注意的是:</p><pre><code>输入层神经元接收外界输入,隐层与输出层神经元对信号进行加工,最终结果由输出层神经元输出.连接的边都具有相应的权值，隐层和输出层的神经单元上还有阀值和激活函数.</code></pre><p><img src="https://img-blog.csdnimg.cn/20210410203809575.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前期介绍完毕，接下来进行误差逆传播(error BackPropagation 简称 <strong>BP</strong> )算法的介绍</p><h3 id="标准BP算法"><a href="#标准BP算法" class="headerlink" title="标准BP算法"></a>标准BP算法</h3><p><img src="https://img-blog.csdnimg.cn/20210410205233136.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_1,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上图是一个三层神经元模型,其中输入层神经元数目为$d$,隐层神经元数目为$q$,输出层神经元数目为$l$,<br>标准BP算法主要针对一个训练样例（假定输入是$\mathbb{R^d}$维,输出是$\mathbb{R^l}$维）更新连接权值和阀值.<br>这里先对一些符号进行说明：</p><ul><li>$x_i$：传输信号,第i个输入神经元的传入信息</li><li>$v_{ih}$：第i个输入神经元与第h个隐层神经元的连接权值</li><li>$\alpha_h$：第h个隐层神经元从输入神经层接收到的信息值,$\alpha_h=\sum_{i=1}^dv_{ih}x_i$</li><li>$\gamma_h$：第h个隐层神经元的阀值(虽未在图中标识,但实际存在)</li><li>$b_h$：第h个隐层神经元的输出值,有公式:$b_h=f_1(\alpha_h-\gamma_h)$,$f_1$为隐层的激活函数</li><li>$w_{hj}$：第h个隐层神经元与第j个输出神经元的连接权值</li><li>$\beta_j$：第j个输出神经元从隐层神经层接收到的信息值,$\beta_j=\sum_{h=1}^qw_{hj}b_h$</li><li>$\theta_j$：第j个输出神经元的阀值(虽未在图中标识,但实际存在)</li><li>$y_j$：第j个输出层神经元的输出值,有公式:$y_j=f_2(\beta_j-\theta_j)$,$f_2$为输出层的激活函数</li></ul><p>$f_1,f_2$一般取sigmod函数，其次分析上面的参数,我们已知$x_i,y_j$,我们需要去求$v_{ih},\gamma_h,w_{hj},\theta_j$，</p><pre><code>需要求解的参数个数为：(d+l+1)q+l,其中:输入层到隐层连边权值:d*q；隐层的阀值:q；隐层到输出层的权值：q*l；输出层的阀值：l总计：d*q+q+q*l+l=(d+l+1)q+l</code></pre><p>我们需要去求解一个比较好的连边权值和阀值。初始随机设定连边权值和阀值,通过计算得到的误差反向修正连边权值和阀值。那么误差怎么计算呢,通过实际的输出和BP神经网络得到的$y_j$进行比较得到误差.</p><p>标准BP算法针对的是一个训练样例(注意是一个样本！！)，假设输入为$X={x_1,x_2,…,x_d}\in\mathbb{R^d}$,输出$Y={y_1,y_2,..,y_l}\in\mathbb{R^l}$。</p><p>通过标准BP算法得到的输出为$\hat{Y}$={$\hat{y_1},\hat{y_2},…,\hat{y_l}$}那么此时该样本的均方误差为:<br>$$<br>E=\frac{1}{2}\sum_{j=1}^l(\hat{y_j}-y_j)^2<br>$$<br>此处前面乘以1/2是人为这样写，方便后面计算,我们通过均方误差对连边权值和阀值进行反向修正</p><p>即有：</p><ul><li>$v\leftarrow v+\Delta v$</li><li>$\gamma\leftarrow \gamma+\Delta \gamma$</li><li>$w\leftarrow w+\Delta w$</li><li>$\theta\leftarrow \theta+\Delta \theta$</li></ul><p>这里主要运用了<strong>梯度下降策略</strong>,以目标的负梯度方向对参数进行调整,对于误差E，给定学习率$\eta$(一般取0.1)，以隐层到输出层的连边权值$w$为例子:<br>$$<br>\Delta w_{hj}=-\eta \frac{\partial E}{\partial w_{hj}}<br>$$<br>我们能发现如下的影响链条$w_{hj}\rightarrow \beta_j \rightarrow \hat{y_j} \rightarrow E$<br>$$<br>\frac{\partial E}{\partial w_{hj}}=\frac{\partial E}{\partial \hat{y_j}}*\frac{\partial \hat{y_j}}{\partial \beta_j}*\frac{\partial \beta_j}{\partial w_{hj}}<br>$$</p><ul><li>$\frac{\partial E}{\partial \hat{y_j}}=\hat{y_j}-y_j$</li><li>$\frac{\partial \hat{y_j}}{\partial \beta_j}=f’_2(\beta_j-\theta_j)=\hat{y_j}(1-\hat{y_j})$</li><li>$\frac{\partial \beta_j}{\partial w_{hj}}=b_h$</li></ul><p>解释以下上面第二个公式,$f’<em>2(\beta_j-\theta_j)=\hat{y_j}(1-\hat{y_j})$  注意：$y_j=f_2(\beta_j-\theta_j)$<br>Sigmod函数的性质:<br>$$<br>f’(x)=(\frac{1}{1+e^{-x}})’=\frac{e^{-x}}{(1+e^{-x})^2}=\frac{1}{1+e^{-x}}*\frac{e^{-x}}{1+e^{-x}}=f(x)(1-f(x))<br>$$<br>所以有:<br>$$<br>\Delta w</em>{hj}=-\eta \frac{\partial E}{\partial w_{hj}}=-\eta*(\hat{y_j}-y_j)*\hat{y_j}(1-\hat{y_j})<em>b_h<br>$$<br>若令$g_j=(y_j-\hat{y_j})<em>\hat{y_j}(1-\hat{y_j})$,上式可化简为:<br>$$<br>\Delta w_{hj}=\eta</em>g_j</em>b_h<br>$$</p><p>类似可通过梯度下降得到其余三个,即</p><ul><li>$\Delta \theta_j=-\eta \frac{\partial E}{\partial \theta_j}=-\eta g_j$</li><li>$\Delta v_{ih}=\frac{\partial E}{\partial v_{ih}}=\eta e_hx_i$</li><li>$\Delta \gamma_h=\frac{\partial E}{\partial \gamma_h}-\eta e_h$</li></ul><p>其中<br>$$<br>e_h=-\frac{\partial E}{\partial b_h}\frac{\partial b_h}{\partial \alpha_h}=-\sum_{j=1}^l\frac{\partial E}{\partial \beta_j}\frac{\partial \beta_j}{\partial b_h}f’(\alpha_h-\gamma_h)=\sum_{j=1}^lw_{hj}g_jf’(\alpha_h-\gamma_h)=b_h(1-b_h)\sum_{j=1}^lw_{hj}g_j<br>$$</p><p>ok，到这里有关标准BP算法的介绍已经讲完了,附上实现的matlab代码</p><pre><code class="c">clear;clc%标准BP算法x=[1.24 1.27];y=[1 0];  %初始数据[v,r,w,h,y_hat]=standard_BP(x,y,3,1e-6);function [v,r,w,h,y_hat]=standard_BP(x,y,q,eps)  %q为隐层单元数目,eps均方误差限q=3;    %隐层单元数目L=length(y);    %输出单元数目n=length(x);  %获取数据的维度v=rand(n,q);  %初始化输入层到隐层的权值r=rand(1,q);    %初始化隐层的阀值w=rand(q,L);  %初始化隐层到输出层的权值h=rand(1,L);    %初始化输出层的阀值k=0.1;        %学习率E=1;while E&gt;eps  A=x*v;                %输入层-&gt;隐层,各个隐层单元具有的权值b=fc_sigmod(A-r);     %经过隐层的激活函数的输出B=b*w;                %隐层-&gt;输出层,各个输出层单元具有的权值y_hat=fc_sigmod(B-h); %经过输出层的激活函数的输出E=0.5*sum((y_hat-y).^2);  %求均方误差%以下对各个系数进行调整g=y_hat.*(1-y_hat).*(y-y_hat);e=b.*(1-b).*(w*g&#39;)&#39;;for i=1:n    for j=1:q        v(i,j)=v(i,j)+k*e(j)*x(i);   %输入层-&gt;隐层的权值更新    endendr=r-k*e;         %隐层的阀值更新for i=1:q    for j=1:L        w(i,j)=w(i,j)+k*g(j)*b(i);   %隐层-&gt;输出层的权值更新    endendh=h-k*g;enddisp(&#39;输入层到隐层的权值为&#39;);vdisp(&#39;隐层的阀值为&#39;);rdisp(&#39;隐层到输出层的权值为&#39;);wdisp(&#39;输出层的阀值为&#39;);hfunction y=fc_sigmod(x)y=1./(1+exp(-x));endend</code></pre><p>我输入数据X=[1.24 1.27],输出数据是Y=[1 0],<br><img src="https://img-blog.csdnimg.cn/20210410225523931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>拟合基本达到了要求,这里的程序不限定样本的输入和输出的维度,可自行调控。</p><p>数据集通常是包含多个样本.在标准BP算法中，对每个样本都会进行更新连边权值和阀值,对一组数据进行训练.这里给出更为一般的标准BP算法.<br><img src="https://img-blog.csdnimg.cn/20210411152754644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>给出数据集，15个样本,输入与输出的维度都为2.</p><pre><code>x=[1.24,1.27;1.36,1.74;1.38,1.64;1.38,1.82;1.38,1.90;1.40,1.70;1.48,1.82;1.54,1.82;1.56,2.08;1.14,1.82;1.18,1.96;1.20,1.86;1.26,2.00 ;1.28,2.00;1.30,1.96];y=[1 0;1 0;1 0;1 0;1 0;1 0;1 0;1 0;1 0;0 1;0 1;0 1;0 1;0 1;0 1];</code></pre><p>这里跳出调整参数，我改成了迭代次数,</p><pre><code class="c">clear;clc%标准BP算法x=[1.24,1.27;1.36,1.74;1.38,1.64;1.38,1.82;1.38,1.90;  1.40,1.70;1.48,1.82;1.54,1.82;1.56,2.08;1.14,1.82;1.18,1.96;1.20,1.86;1.26,2.00  1.28,2.00;1.30,1.96];y=[1 0;1 0;1 0;1 0;1 0;1 0;1 0;1 0;1 0;0 1;0 1;0 1;0 1;0 1;0 1];  %初始数据[v,r,w,h,y_hat]=standard_BP(x,y,3,1e6);x_k=[1.24 1.80;1.28 1.84;1.40 2.04];function [v,r,w,h,y_hat]=standard_BP(x0,y0,q,N)  %q为隐层单元数目,N,迭代次数%初始化连边权值和阀值L=size(y0,2);    %输出单元数目[m,n]=size(x0);  %获取数据的维度v=rand(n,q);  %初始化输入层到隐层的权值r=rand(1,q);    %初始化隐层的阀值w=rand(q,L);  %初始化隐层到输出层的权值h=rand(1,L);    %初始化输出层的阀值k=0.05;        %学习率E=1;iter=1;a=1;while iter&lt;N    x=x0(a,:);    y=y0(a,:);        A=x*v;                %输入层-&gt;隐层,各个隐层单元具有的权值    b=fc_sigmod(A-r);     %经过隐层的激活函数的输出        B=b*w;                %隐层-&gt;输出层,各个输出层单元具有的权值    y_hat(a,:)=fc_sigmod(B-h); %经过输出层的激活函数的输出        E=0.5*sum((y_hat(a,:)-y).^2);  %求均方误差        %以下对各个系数进行调整    g=y_hat(a,:).*(1-y_hat(a,:)).*(y-y_hat(a,:));    e=b.*(1-b).*(w*g&#39;)&#39;;        for i=1:n        for j=1:q            v(i,j)=v(i,j)+k*e(j)*x(i);   %输入层-&gt;隐层的权值更新        end    end    r=r-k*e;         %隐层的阀值更新        for i=1:q        for j=1:L            w(i,j)=w(i,j)+k*g(j)*b(i);   %隐层-&gt;输出层的权值更新        end    end    h=h-k*g;        if a&gt;=m        a=a-m;    end    a=a+1;    iter=iter+1;enddisp(&#39;输入层到隐层的权值为&#39;);vdisp(&#39;隐层的阀值为&#39;);rdisp(&#39;隐层到输出层的权值为&#39;);wdisp(&#39;输出层的阀值为&#39;);hfunction y=fc_sigmod(x)y=1./(1+exp(-x));endend</code></pre><p><img src="https://img-blog.csdnimg.cn/20210411144538764.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>调整后，输出的y_hat值达到较高的精度</p><hr><h3 id="累积BP算法"><a href="#累积BP算法" class="headerlink" title="累积BP算法"></a>累积BP算法</h3><p>因为标准BP算法每次更新都只针对单个样例,参数更新得非常频繁,而且对不同样例进行更新的效果可能出现“抵消”现象,因此，为了达到同样的累积误差极小点,标准BP算法往往需要进行更多次数的迭代.累积BP算法直接针对累积误差最小化,它在读取整个训练集D一遍后才对参数进行更新,其参数更新的频率低得多.<br>这里给出累积误差公式:<br>$$<br>\hat{E}=\frac{1}{m}\sum_{k=1}^mE_k<br>$$<br>我们用累积误差$\hat{E}$去对参数进行调整,举一个例子,比如：</p><ul><li>$\Delta w_{hj}=-\eta\frac{\partial \hat{E}}{\partial w_{hj}}=-\eta\sum_{k=1}^m\frac{\partial \hat{E}}{\partial E_k}\frac{\partial E_k}{\partial w_{hj}}=-\eta\frac{1}{m}\sum_{k=1}^m\frac{\partial E_k}{\partial w_{hj}}$<br>计算出m个样本的$\frac{\partial E_k}{\partial w_{hj}}$后取均值,即可</li></ul><p>当然,我们可以对上式进行进一步化简,由标准BP算法，我们有：</p><ul><li>$\Delta w_{hj}=\eta g_jb_h$</li><li>$\Delta \theta_j=-\eta \frac{\partial E}{\partial \theta_j}=-\eta g_j$</li><li>$\Delta v_{ih}=\eta e_hx_i$</li><li>$\Delta \gamma_h=-\eta e_h$</li></ul><pre><code>我们只需要把对应的g_j,b_h,e_h以及x_i对应位置上通过m个样本计算完后,在其对应位置上取均值即可。</code></pre><p>这里附上累积BP算法:</p><pre><code class="c">clear;clc%累积BP算法x=[1.24,1.27;1.36,1.74;1.38,1.64;1.38,1.82;1.38,1.90;  1.40,1.70;1.48,1.82;1.54,1.82;1.56,2.08;1.14,1.82;1.18,1.96;1.20,1.86;1.26,2.00  1.28,2.00;1.30,1.96];y=[1 0;1 0;1 0;1 0;1 0;1 0;1 0;1 0;1 0;0 1;0 1;0 1;0 1;0 1;0 1];  %初始数据[v,r,w,h,y_hat]=acc_BP(x,y,3,1e3);function [v,r,w,h,y_hat]=acc_BP(x0,y0,q,N)  %q为隐层单元数目,N为迭代次数%初始化连边权值和阀值L=size(y0,2);    %输出单元数目[m,n]=size(x0);  %获取样本个数以及数据维度v=rand(n,q);  %初始化输入层到隐层的权值r=rand(1,q);    %初始化隐层的阀值w=rand(q,L);  %初始化隐层到输出层的权值h=rand(1,L);    %初始化输出层的阀值k=0.1;        %学习率iter=1;while iter&lt;Nfor i=1:m    x=x0(i,:);    y=y0(i,:);    A=x*v;                %输入层-&gt;隐层,各个隐层单元具有的权值    b(i,:)=fc_sigmod(A-r);     %经过隐层的激活函数的输出    B=b(i,:)*w;                %隐层-&gt;输出层,各个输出层单元具有的权值y_hat(i,:)=fc_sigmod(B-h); %经过输出层的激活函数的输出    %以下对各个系数进行调整g(i,:)=y_hat(i,:).*(1-y_hat(i,:)).*(y-y_hat(i,:));e(i,:)=b(i,:).*(1-b(i,:)).*(w*g(i,:)&#39;)&#39;;    end%对上述梯度下降策略后的调整至取均值b_bar=mean(b);g_bar=mean(g);e_bar=mean(e);    E=mean(sum((y_hat-y0).^2,2));  %求均方误差    for i=1:n        for j=1:q            v(i,j)=v(i,j)+k*e_bar(j)*mean(x0(:,i));   %输入层-&gt;隐层的权值更新        end    end    r=r-k*e_bar;         %隐层的阀值更新        for i=1:q        for j=1:L            w(i,j)=w(i,j)+k*g_bar(j)*b_bar(i);   %隐层-&gt;输出层的权值更新        end    end    h=h-k*g_bar;        %输出层的阀值更新    iter=iter+1;    enddisp(&#39;输入层到隐层的权值为&#39;);vdisp(&#39;隐层的阀值为&#39;);rdisp(&#39;隐层到输出层的权值为&#39;);wdisp(&#39;输出层的阀值为&#39;);hdisp(&#39;此时误差E为&#39;);Efunction y=fc_sigmod(x)y=1./(1+exp(-x));endend</code></pre><p><img src="https://img-blog.csdnimg.cn/20210411151735405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里调整后求出的$\hat{y}$效果不是很好，后期数据收敛了。</p><p>我们通过神经网络的内在结构求出各个连边权值和阀值,由有标签的数据，去预测无标签的数据类型。最后，我附上自己编写的预测代码</p><pre><code class="c">function y_hat=standard_BP_predict(data,v,r,w,h)[m,n]=size(data);for i=1:m    x=data(i,:);    A=x*v;                %输入层-&gt;隐层,各个隐层单元具有的权值    b=fc_sigmod(A-r);     %经过隐层的激活函数的输出        B=b*w;                %隐层-&gt;输出层,各个输出层单元具有的权值    y_hat(i,:)=fc_sigmod(B-h); %经过输出层的激活函数的输出endfunction y=fc_sigmod(x)y=1./(1+exp(-x));endend</code></pre><p>data是我们需要去预测的数据,得到其类型,而v,r,w,h是前期可通过标准BP算法或者累积BP算法算得。</p><pre><code class="bash">当然，想要获得精度更准确的数据，还得参考其他大量有关BP算法的文章。本文只是简易的对标准BP算法以及累积BP算法做个实现.</code></pre>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning,Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准BP算法和累积BP算法Python实现</title>
      <link href="/2021/060633523.html"/>
      <url>/2021/060633523.html</url>
      
        <content type="html"><![CDATA[<p>以下是自己编写的Python的代码,欢迎指正</p><p>标准BP算法:</p><pre><code class="c">import numpy as npx=np.matrix(np.random.rand(3,2)) #输入层,随机生成3个样本,每个样本有2个神经元y=np.matrix(np.random.rand(3,2)) #输出层,随机生成3个样本，每个样本有2个神经元q=3N=100000k = 0.1&#39;&#39;&#39;q: 隐层单元数目v: 输入层到隐层的权值r: 隐层的阀值w: 隐层到输出层的权值h: 输出层的阀值k: 学习率&#39;&#39;&#39;def fc_sigmod(x):    return 1/(1+np.exp(-x))def standard_BP(x0,y0,q,N,k):    L=y0.shape[1]    n=x0.shape[1]    v=np.matrix(np.random.rand(n,q))    r=np.matrix(np.random.rand(1,q))    w=np.matrix(np.random.rand(q,L))    h=np.matrix(np.random.rand(1,L))    index=0    y_hat = np.matrix(np.zeros((x0.shape[0],L)))    iter=1    while iter&lt;N:        A=np.dot(x[index],v)        b=fc_sigmod(A-r)        B=np.dot(b,w)        # print(h)        y_hat[index]=fc_sigmod(B-h)        # E=0.5*np.dot(y[index]-y_hat[index],(y[index]-y_hat[index]).T)        &#39;以下对各个系数进行调整&#39;        g=np.multiply(np.multiply(y_hat[index],(1-y_hat[index])),y[index]-y_hat[index])        e=np.multiply(np.multiply(b,(1-b)),(w*g.T).T)        for i in range(n):            for j in range(q):                v[i,j]=v[i,j]+k*e[0,j]*x[index,i]        r=r-k*e        for i in range(q):            for j in range(L):                w[i,j]=w[i,j]+k*g[0,j]*b[0,i]        h=h-k*g        if index&gt;=x0.shape[0]-1:            index=index-x0.shape[0]+1        index = index +1        iter=iter+1    print(&#39;输入层到隐层的权值为:&#39;)    print(v)    print(&#39;隐层的阀值为：&#39;)    print(r)    print(&#39;隐层到输出层的权值为:&#39;)    print(w)    print(&#39;输出层的阀值为：&#39;)    print(h)    print(&#39;样本y的值&#39;)    print(y)    print(&#39;训练后能得到y_hat的值&#39;)    print(y_hat)standard_BP(x,y,q,N,k)</code></pre><p><img src="https://img-blog.csdnimg.cn/20210412221620842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们看到训练后预测的y_hat值与原先的已经比较接近了。当然这里的标准BP算法实现比较简单~</p><p>累积BP算法:</p><pre><code class="c">import numpy as npx=np.matrix(np.random.rand(3,2)) #输入层,随机生成3个样本,每个样本有2个神经元y=np.matrix(np.random.rand(3,2)) #输出层,随机生成3个样本，每个样本有2个神经元q=3N=50000k = 0.1&#39;&#39;&#39;q: 隐层单元数目v: 输入层到隐层的权值r: 隐层的阀值w: 隐层到输出层的权值h: 输出层的阀值k: 学习率&#39;&#39;&#39;def fc_sigmod(x):    return 1/(1+np.exp(-x))def acc_BP(x,y,q,N,k):    L=y.shape[1]    n=x.shape[1]    v=np.matrix(np.random.rand(n,q))    r=np.matrix(np.random.rand(1,q))    w=np.matrix(np.random.rand(q,L))    h=np.matrix(np.random.rand(1,L))    b=np.matrix(np.zeros((x.shape[0],q)))    g=np.matrix(np.zeros((x.shape[0],n)))    e=np.matrix(np.zeros((x.shape[0],q)))    y_hat = np.matrix(np.zeros((x.shape[0],L)))    iter=1    while iter&lt;N:        for index in range(x.shape[0]):            A=np.dot(x[index],v)            b[index]=fc_sigmod(A-r)            B = np.dot(b[index],w)            y_hat[index]=fc_sigmod(B-h)            g[index]=np.multiply(np.multiply(y_hat[index],(1-y_hat[index])),y[index]-y_hat[index])            e[index]=np.multiply(np.multiply(b[index],(1-b[index])),(w*g[index].T).T)        #以下对各个系数进行调整        #对上述的一些系数调整至取均值        b_bar=b.mean(axis=0)        g_bar=g.mean(axis=0)        e_bar=e.mean(axis=0)        x_bar=x.mean(axis=0)        for i in range(n):            for j in range(q):                v[i,j]=v[i,j]+k*e_bar[0,j]*x_bar[0,i]        r=r-k*e_bar        for i in range(q):            for j in range(L):                w[i,j]=w[i,j]+k*g_bar[0,j]*b_bar[0,i]        h=h-k*g_bar        iter=iter+1    print(&#39;输入层到隐层的权值为:&#39;)    print(v)    print(&#39;隐层的阀值为：&#39;)    print(r)    print(&#39;隐层到输出层的权值为:&#39;)    print(w)    print(&#39;输出层的阀值为：&#39;)    print(h)    print(&#39;样本y的值&#39;)    print(y)    print(&#39;训练后能得到y_hat的值&#39;)    print(y_hat)acc_BP(x,y,q,N,k)</code></pre><p><img src="https://img-blog.csdnimg.cn/20210413113503463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里训练后得到的效果不是很好，和自己先前用Matlab写的累积BP算法一样,训练后得到的y_hat值不是很准确.要想获得更加准确的模型，可以考虑一下几个因素</p><ul><li>隐层和输出层的激活函数的选取（我们这里选取的都是sigmod函数）</li><li>学习因子</li><li>迭代次数</li><li>增加隐层单元数目</li><li>设置多隐层(我们这里只设置了一个隐层)</li></ul>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning,Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现聚类 KMeans算法</title>
      <link href="/2021/060642162.html"/>
      <url>/2021/060642162.html</url>
      
        <content type="html"><![CDATA[<pre><code class="python">#-*- coding: utf-8 -*-&#39;&#39;&#39;# author： 影子# datetime： 2021-05-18 12:10 # ide： PyCharmtarget : 完成一个简单的KMeans聚类算法&#39;&#39;&#39;from numpy import *# 欧式距离函数def Euclidean_Distance(vecA,vecB):    return sqrt(sum(power(vecA-vecB,2)))# 随机设置k个质心def Rand_Cent(DataSet,k):    n = shape(DataSet)[1]     # 获取数据集的维度    centroids = mat(zeros([k,n]))  # 初始化一个k行n列的二维数组，数组初始值全部为0，然后用mat函数将其转化为矩阵    for j in range(n):        minj = min(DataSet[:,j])        rangej = float(max(DataSet[:,j])-minj)        centroids[:,j] = mat(minj+rangej*random.rand(k,1)) # 随机生成一个范围在[min_j,max_j]的数据    return centroids   # 返回k个初始质心# k-Means算法实现def kMeans(DataSet,k,Dist=Euclidean_Distance,set_cent=Rand_Cent):    &#39;&#39;&#39;    :param DataSet: 需要聚类的数据集    :param k: 聚类数目    :param Dist: 距离函数,此处调用了欧式距离函数    :param set_cent: 初始质心函数，此处调用随机生成的质心函数    :return: 质心点；数据对应的聚类簇    &#39;&#39;&#39;    m = shape(DataSet)[0]   # 获取样本个数    centoids = set_cent(DataSet,k)  # 初始化质心    clusterAssment = mat(zeros((m,2))) # 第一列存放每个样本的聚类簇，第二列存放对该样本到该聚类中心的距离    clusterChanged = True    while clusterChanged:        clusterChanged = False        for i in range(m):   # 遍历所有样本            minDist = inf # 初始设定最小距离为无穷大            minIdex = -1 # 初始设定样本聚类簇为 -1            for j in range(k): # 对每个样本，计算到其他k个聚类中心的距离                DistJI = Dist(centoids[j,:],DataSet[i,:])                if minDist &gt; DistJI:  # 该样本到最小距离的聚类中心记录下来,此样本记录为该簇                    minDist = DistJI                    minIdex = j            if clusterAssment[i,0] != minIdex: # 判断样本所属簇是否更新，若更新则记为True                clusterChanged = True            clusterAssment[i,:]=minIdex,minDist # 将样本的聚类簇和到该聚类簇中心的距离记录下来        for cent_i in range(k):            cluster = DataSet[nonzero(clusterAssment[:,0].A==cent_i)[0]]            &#39;&#39;&#39;            clusterAssment[:,0]：记录每个样本的聚类簇            clusterAssment[:,0].A：将其转化为行矩阵            nonzero(clusterAssment[:,0].A==cent_i)[0]：获得元素为Ture的样本下标            整句含义：获得数据集中聚类簇为cent_i的样本            &#39;&#39;&#39;            centoids[cent_i,:] = mean(cluster,axis=0) # 按行取均值    return centoids,clusterAssment # 返回质心点；每个样本的(聚类簇+最短距离)# 画图def show(DataSet,k,centroids,clusterAssment):    from matplotlib import pyplot as plt    m,n = DataSet.shape    mark = [&#39;or&#39;, &#39;ob&#39;, &#39;og&#39;, &#39;ok&#39;, &#39;^r&#39;, &#39;+r&#39;, &#39;sr&#39;, &#39;dr&#39;, &#39;&lt;r&#39;, &#39;pr&#39;] # 样本集的样式    for i in range(m):        markIdex = int(clusterAssment[i,0])        plt.plot(DataSet[i,0],DataSet[i,1],mark[markIdex])    mark= [&#39;Dr&#39;, &#39;Db&#39;, &#39;Dg&#39;, &#39;Dk&#39;, &#39;^b&#39;, &#39;+b&#39;, &#39;sb&#39;, &#39;db&#39;, &#39;&lt;b&#39;, &#39;pb&#39;] # 质点的样式    for i in range(k):        plt.plot(centroids[i,0],centroids[i,1],mark[i],markersize=20)    plt.show()def main():    DataSet = random.rand(100,2) # 随机生成100行2列的数据    DataSet = mat(DataSet) # 转化为矩阵    k=4 # 设置聚类簇    myCentroids,clustAssing = kMeans(DataSet,k) # 调用kMeans算法    print(&#39;聚类的质心为&#39;)    print(myCentroids)    show(DataSet,k,myCentroids,clustAssing)  # 画图if __name__ == &#39;__main__&#39;:    main()</code></pre><p><img src="https://img-blog.csdnimg.cn/20210518134759975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning,Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex——从基础表到进阶表的讲述</title>
      <link href="/2021/060615907.html"/>
      <url>/2021/060615907.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>Latex录入表格一般使用tabular</p><p>基本格式如下：</p><pre><code>\begin&#123;tabular&#125;&#123;对齐方式&#125;&lt;表项&gt; &amp; &lt;表项&gt; &amp;...&amp; \\&lt;表项&gt; &amp; &lt;表项&gt; &amp;...&amp; \\\end&#123;tabular&#125;</code></pre><p>现在对对齐方式进行简单的描述</p><ul><li>l(L的小写)：本列左对齐</li><li>c：本列居中对齐</li><li>r：本列居右对齐</li></ul><p>一般情况下我们都使用c(centering的第一个字母),{对齐方式}-&gt;{ccc}，表示三列的内容都是居中对齐。</p><p>讲个例子：</p><pre><code class="cpp">\documentclass&#123;article&#125;\begin&#123;document&#125;        \begin&#123;tabular&#125;&#123;cccc&#125;        a11 &amp; a12 &amp; a13  &amp; b1 \\    a21 &amp; a22  &amp; a23 &amp; b2  \\     a31 &amp; a32  &amp; a33 &amp; b3  \\    \end&#123;tabular&#125;    \end&#123;document&#125;</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/2021012816525360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当然，我们还可以适当的给这个表格添加横、竖线。</p><pre><code>横线：需要在该行添加语句\hline,竖线：需要在&#123;对齐方式&#125;这里进行设置，例如&#123;cc|c&#125;，表示在第二三列之间添加竖线</code></pre><p>例子如下：</p><pre><code class="cpp">\documentclass&#123;article&#125;\begin&#123;document&#125;        \begin&#123;tabular&#125;&#123;c|c|cc&#125;    \hline    a11 &amp; a12 &amp; a13  &amp; b1 \\    a21 &amp; a22  &amp; a23 &amp; b2  \\     \hline    a31 &amp; a32  &amp; a33 &amp; b3  \\    \end&#123;tabular&#125;    \end&#123;document&#125;</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210128165834342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三线表"><a href="#三线表" class="headerlink" title="三线表"></a>三线表</h1><p>了解前面的语法，接下来便可以做出三线表的效果了。</p><p>例子如下：</p><pre><code class="cpp">\documentclass&#123;article&#125;\begin&#123;document&#125;        \begin&#123;tabular&#125;&#123;ccc&#125;    \hline    id &amp; name &amp; sex  \\    \hline    1 &amp; John  &amp; man  \\     2 &amp; Jack  &amp; woman \\    \hline    \end&#123;tabular&#125;    \end&#123;document&#125;</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210128170504295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通常情况，为了让表格更具美感，我们希望第一根线和最后一根线比中间那根线更粗点。此时我们需要引入宏包<strong>booktabs</strong>,之后便可以使用\toprule 和 \bottomrule 命令分别画出表格头和表格底的粗横线，而用 \midrule 画出表格中的横线。</p><p>例子如下：</p><pre><code class="cpp">\documentclass&#123;article&#125;\usepackage&#123;booktabs&#125;\begin&#123;document&#125;        \begin&#123;tabular&#125;&#123;ccc&#125;    \toprule    id &amp; name &amp; sex  \\    \midrule    1 &amp; John  &amp; man  \\     2 &amp; Jack  &amp; woman \\    \bottomrule    \end&#123;tabular&#125;    \end&#123;document&#125;</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210128171050629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="单元格合并"><a href="#单元格合并" class="headerlink" title="单元格合并"></a>单元格合并</h1><p>在唠唠怎么给他做单元格合并。<br>对于某一行</p><pre><code>\multicolum&#123;行数&#125;&#123;对齐方式&#125;&#123;文本内容&#125;</code></pre><p>例子如下：</p><pre><code class="cpp">\documentclass&#123;article&#125;\begin&#123;document&#125;        \begin&#123;tabular&#125;&#123;|c|c|c|&#125;    \multicolumn&#123;3&#125;&#123;c&#125;&#123;information&#125; \\    \hline    id &amp; name &amp; sex  \\    \hline    1 &amp; John  &amp; man  \\     \hline    2 &amp; Jack  &amp; woman \\    \hline    \end&#123;tabular&#125;    \end&#123;document&#125;</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210128171846707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于列的单元格合并，需要导入包</p><pre><code>\usepackage&#123;multirow&#125;</code></pre><p>例子如下：</p><pre><code class="cpp">\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125;        \begin&#123;tabular&#125;&#123;|c|c|c|c|&#125;    \hline    \multicolumn&#123;4&#125;&#123;|c|&#125;&#123;information&#125; \\    \hline    \multirow&#123;3&#125;*&#123;data&#125;   &amp;id &amp; name &amp; sex  \\   \cline&#123;2-4&#125;      %%只为第2-4列添加横线    &amp;1 &amp; John  &amp; man  \\     \cline&#123;2-4&#125;      %%只为第2-4列添加横线    &amp;2 &amp; Jack  &amp; woman \\    \hline    \end&#123;tabular&#125;    \end&#123;document&#125;</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210128173217649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在，我们用上面的合并基础语法，来做一个稍微复杂点的表格<br>例子如下</p><pre><code class="cpp">\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;|c|c|c|c|c|c|c|&#125;\hline\multicolumn&#123;2&#125;&#123;|c|&#125;&#123; \multirow&#123;2&#125;*&#123;$S_i$&#125; &#125;&amp; \multicolumn&#123;4&#125;&#123;c|&#125;&#123;x&#125; &amp;\multirow&#123;2&#125;*&#123;max&#125;\\\cline&#123;3-6&#125;\multicolumn&#123;2&#125;&#123;|c|&#125;&#123;&#125;&amp;50&amp;100&amp;150&amp;200&amp;\\\hline\multirow&#123;4&#125;*&#123;y&#125;&amp;50&amp;0&amp;100&amp;200&amp;300&amp;300\\\cline&#123;2-7&#125;&amp;100&amp;100&amp;0&amp;100&amp;200&amp;200\\\cline&#123;2-7&#125;&amp;150&amp;200&amp;100&amp;0&amp;100&amp;200\\\cline&#123;2-7&#125;&amp;200&amp;300&amp;200&amp;100&amp;0&amp;300\\\hline\end&#123;tabular&#125;    \end&#123;document&#125;</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210128174024334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们还可以做一个<strong>斜线表头</strong>，需要导入包</p><pre><code>\usepackage&#123;diagbox&#125;</code></pre><p>例子如下</p><pre><code class="cpp">\documentclass&#123;article&#125;\usepackage&#123;diagbox&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;|c|c|c|c|&#125;    \hline    \diagbox&#123;A&#125;&#123;$\alpha_&#123;i,j&#125;$&#125;&#123;B&#125;&amp;$\beta_1$&amp;$\beta_2$&amp;$\beta_3$\\ %添加斜线表头    \hline    $\alpha_1$&amp;-4&amp;0&amp;-8\\    \hline    $\alpha_2$&amp;3&amp;2&amp;4\\    \hline    $\alpha_3$&amp;16&amp;1&amp;-9\\    \hline    $\alpha_4$&amp;-1&amp;1&amp;7\\    \hline\end&#123;tabular&#125;    \end&#123;document&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210128174506264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果我们需要斜线+单元格并列效果。<br>先简单讲一个例子：</p><pre><code class="bash">\documentclass&#123;article&#125;\usepackage&#123;diagbox&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125;  \begin&#123;tabular&#125;&#123;|c|c|c|c|c|c|c|&#125;    \hline    \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;\multirow&#123;2&#125;*&#123;\diagbox&#123;$S_i$&#125;&#123;$\lambda_i$&#125;&#125;&#125;&amp; \multicolumn&#123;4&#125;&#123;c|&#125;&#123;x&#125; &amp;\multirow&#123;2&#125;*&#123;max&#125;\\    \cline&#123;3-6&#125;    \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;&#125;&amp;50&amp;100&amp;150&amp;200&amp;\\    \hline    \multirow&#123;4&#125;*&#123;y&#125;&amp;50&amp;0&amp;100&amp;200&amp;300&amp;300\\    \cline&#123;2-7&#125;    &amp;100&amp;100&amp;0&amp;100&amp;200&amp;200\\    \cline&#123;2-7&#125;    &amp;150&amp;200&amp;100&amp;0&amp;100&amp;200\\    \cline&#123;2-7&#125;    &amp;200&amp;300&amp;200&amp;100&amp;0&amp;300\\    \hline    \end&#123;tabular&#125;    \end&#123;document&#125;</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210128174805189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上述就完成这个要求，注意调节\diagbox[innerwidth=2cm]，如果斜线对不准，请条件这个参数</p><h1 id="table环境"><a href="#table环境" class="headerlink" title="table环境"></a>table环境</h1><p>我们在写论文时，需要将表格插入文档中，表格的环境是table，类似于图片的环境是figure。基本的用法和图片环境figure类似，这里也简单的提一下吧</p><pre><code>\begin&#123;table&#125;[htbp]\centering   %居中\caption&#123;名称&#125;\label&#123;&#125;    %引用表格所需\begin&#123;tabular&#125;&#123;对齐方式&#125;........\end&#123;tabular&#125;\end&#123;table&#125;</code></pre><p><code>[htbp]</code>，选择将表格放入文档中的哪个位置</p><pre><code>h（here）:将表格插入在当前文字位置t（top）:将表格放在下一页首b（bottoom）:将表格放在当前页底部p（page）:放入下一页</code></pre><p>简单讲一个例子：</p><pre><code class="bash">\documentclass&#123;article&#125;\begin&#123;document&#125;        As the favorable food for Scotch, the herring and mackerel bring generous profits to fishing    companies. Due to the hotter ocean, more fish move to the north to seek better habitats, laying a    negative impact on the fishing industry. The aim of this report is to build a migratory prediction    model to evaluate the influences on the income of fishing companies. We are expected to provide    some strategies for fishing companies who can adapt to the migration of fish under the constraints of    various objective conditions and prevent themselves from going bankrupt as much as possible. Three    models are established: Model I: Seawater Temperature Prediction Model; Model II: Fish Migration    Prediction Model; Model III: Fishing Company Earnings Evaluation Model.            \begin&#123;table&#125;[htbp]        \centering        \caption&#123;三线表&#125;        \label&#123;tab:1&#125;\begin&#123;tabular&#125;&#123;ccc&#125;\hlinename&amp; id&amp; sex\\\hlineSteve Jobs&amp; 001&amp; Male\\Bill Gates&amp; 002&amp; Female\\\hline\end&#123;tabular&#125;    \end&#123;table&#125;For Model I, global ocean temperature date monthly from 1960 to 2019 is firstly collected. Then,based on the analysis of intrinsic trend of the data and the verification of the stationarity, the validationof using ARIMA model to predict temperature is proved. Next, historical data is used to fit theparameters of ARIMA, with introduction of k-fold cross validation to identify the final predictionmodel as ARIMA(1,1,0). Finally, according to ARIMA(1,1,0), bootstrap method is used to simulate10000 possible prediction cases, which lays a great foundation to predict the migration of fish.\end&#123;document&#125;</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210128180634725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果你还是不会用，在此给你留个链接<a href="https://www.tablesgenerator.com/#">Latex表格在线网址</a><br>欢迎有问题给我留言~</p>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex——伪代码算法</title>
      <link href="/2021/060658338.html"/>
      <url>/2021/060658338.html</url>
      
        <content type="html"><![CDATA[<p>一般在论文的写作中，需要有算法流程图，现讲述两种伪代码算法流程图的实现：algorithm,algorithme2</p><p>第一个：algorithm</p><pre><code>%导包\usepackage&#123;algorithm&#125;\usepackage&#123;algorithmic&#125;</code></pre><p>完整代码：</p><pre><code class="cpp">\documentclass&#123;article&#125;\usepackage&#123;algorithm&#125;\usepackage&#123;algorithmic&#125;\begin&#123;document&#125;    \begin&#123;algorithm&#125;    \renewcommand&#123;\algorithmicrequire&#125;&#123;\textbf&#123;Input:&#125;&#125;    \renewcommand&#123;\algorithmicensure&#125;&#123;\textbf&#123;Output:&#125;&#125;    \caption&#123;Bayesian Personalized Ranking Based Latent Feature Embedding Model&#125;    \label&#123;alg:1&#125;    \begin&#123;algorithmic&#125;[1]        \REQUIRE latent dimension $K$, $G$, target predicate $p$        \ENSURE $U^&#123;p&#125;$, $V^&#123;p&#125;$, $b^&#123;p&#125;$        \STATE Given target predicate $p$ and entire knowledge graph $G$, construct its bipartite subgraph, $G_&#123;p&#125;$         \STATE $m$ = number of subject entities in $G_&#123;p&#125;$        \STATE $n$ = number of object entities in $G_&#123;p&#125;$         \STATE Generate a set of training samples $D_&#123;p&#125; = \&#123;(s_p, o^&#123;+&#125;_&#123;p&#125;, o^&#123;-&#125;_&#123;p&#125;)\&#125;$ using uniform sampling technique        \STATE Initialize $U^&#123;p&#125;$ as size $m \times K$ matrix with $0$ mean and standard deviation $0.1$        \STATE Initialize $V^&#123;p&#125;$ as size $n \times K$ matrix with $0$ mean and stardard deviation $0.1$        \STATE Initialize $b^&#123;p&#125;$ as size $n \times 1$ column vector with $0$ mean and stardard deviation $0.1$        \FORALL&#123;$(s_p, o^&#123;+&#125;_&#123;p&#125;, o^&#123;-&#125;_&#123;p&#125;) \in D_&#123;p&#125;$&#125;        \STATE Update $U_&#123;s&#125;^&#123;p&#125;$ based on Equation~\ref&#123;eq:sgd1&#125;        \STATE Update $V_&#123;o^&#123;+&#125;&#125;^&#123;p&#125;$ based on Equation~\ref&#123;eq:sgd2&#125;        \STATE Update $V_&#123;o^&#123;-&#125;&#125;^&#123;p&#125;$ based on Equation~\ref&#123;eq:sgd3&#125;        \STATE Update $b_&#123;o^&#123;+&#125;&#125;^&#123;p&#125;$ based on Equation~\ref&#123;eq:sgd4&#125;        \STATE Update $b_&#123;o^&#123;-&#125;&#125;^&#123;p&#125;$ based on Equation~\ref&#123;eq:sgd5&#125;        \ENDFOR        \STATE \textbf&#123;return&#125; $U^&#123;p&#125;$, $V^&#123;p&#125;$, $b^&#123;p&#125;$    \end&#123;algorithmic&#125;  \end&#123;algorithm&#125;\end&#123;document&#125;</code></pre><p>结果如下<br><img src="https://img-blog.csdnimg.cn/20210127224832973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>第二个：algorith2me</p><pre><code>%导包\usepackage[ruled]&#123;algorithm2e&#125;</code></pre><p>完整代码</p><pre><code class="cpp">\documentclass&#123;article&#125;\usepackage[ruled]&#123;algorithm2e&#125;\begin&#123;document&#125;\begin&#123;algorithm&#125;[h]        \caption&#123;The process of location change of fish&#125;      \label&#123;alg:1&#125;    \KwIn&#123;$\rho(x,y,0),\beta,v_&#123;max&#125;,u_&#123;min&#125;,u_&#123;max&#125;$&#125;    \KwOut&#123;$\rho(x,y,50)$&#125;          \For&#123;t=1 to 50&#125;&#123;        The random distractor $\epsilon_t$ can be get in the process of identification of variance \newline        The dispersed $u(x, y, t)$ can be predicted based on the model ARIMA(1,1,0) and the $u(x, y, t 1)$ \newline        The continuous $u(x, y, t)$ can be get based on the linear interposition of value of the dispersed $u(x, y, t)$\newline        The continuous $\nabla u$ can be identified based on the equation (11) \newline        The continuous $v(x, y, t)$ can be calculated based on the equation (12) \newline        The location change of each fish can be calculated based on equation (7) \newline        The $\rho_t(x, y)$ of each fish can be refreshed based on the equation (8) \newline    &#125;\end&#123;algorithm&#125;  \end&#123;document&#125;  </code></pre><p>结果如下<br><img src="https://img-blog.csdnimg.cn/20210127225255881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>关于 <strong>algorithm2e</strong>的补充</p><pre><code>\usepackage[ruled,linesnumbered]&#123;algorithm2e&#125;</code></pre><ul><li><code>ruled</code> 让标题显示在上方，否则将显示在下方</li><li><code>linesnumbered</code> 在算法流程图内显示行号</li><li>可添加 <code>boxed</code>，让算法排版时插入在一个盒子里</li></ul><p> 展示效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20210127230434622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>另外补充：</p><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td>\;</td><td>在行末添加分号，并自动换行</td></tr></tbody></table><p>| \caption{}|插入标题<br>\KwIn{输入消息}|效果为：“input:输入消息”<br>KwOut{输出消息}|效果为：“Out:输出消息”<br>KwData{输入消息}|效果为：“Data:输入消息”<br>KwResult{输出消息}|效果为：“Result:输出消息”<br>\For{条件}{循环语句}|for 条件 do 循环语句 end<br>\If{条件}{肯定语句}|if 条件 then 肯定语句 end<br>|While{条件}{循环语句}|while 条件 then 循环语句 end<br>\tcc{注释}|/*注释*/<br>\tcp{注释}|//注释<br>\elf{条件}{肯定语句}{否定语句}|if 条件 then 肯定语句 else 否定语句 end</p><p>如果有问题，欢迎给我留言</p>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex——图片基本插入及多图并排</title>
      <link href="/2021/060656548.html"/>
      <url>/2021/060656548.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Latex的基本插图"><a href="#Latex的基本插图" class="headerlink" title="Latex的基本插图"></a>Latex的基本插图</h1><p>插图功能不是有Latex的内核直接提供的，而是需要由宏包graphicx提供的。因此要使用宏包的话，我们就需要在引言区插入我们的宏包。</p><p>注:插图的宏包还可使用graphics，两个宏包在功能上几乎无差别，只是graphicx宏包支持&lt;项目&gt;=&lt;值&gt;的语法，使用起来更方便。</p><p>导入宏包之后我们就可以使用\includegraphics命令进行插图。</p><pre><code class="cpp">\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;    \includegraphics[scale=0.4]&#123;lufei1&#125;\end&#123;document&#125;</code></pre><p>在文本相同路径下放置一张名叫lufei1的图片，后面的格式是jpg,png可以忽略。我们就可以得到一张插入的图片了。<br><img src="https://img-blog.csdnimg.cn/20210127235732976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>\includegraphics[scale=0.6]&#123;lufei1&#125;</code></pre><p>里面有两个参数，第一个参数是可不写，第二个参数是指定图片。</p><p><strong>有关第一个参数：</strong> 为更加符合文档的要求，我们需要对所插的图片进行适当的调整</p><pre><code>width=3cm[缩放因子]                     指定宽度为3cmheight=8cm[缩放因子]                    指定高度为8cmscale=0.4[缩放因子]                  按0.4的比例缩小</code></pre><p><strong>有关第二个参数：</strong> 插入图片时，忽略后缀jpg或者png。<br>我们在写论文的时候，一般如果图片比较多我们一般会选择把图片统一的放到和源文件一个路径下的某个目录里，这个时候我们要成功的加载图片我们就可以使用相对路径或绝对路径来加载。<br><code>相对路径</code> ：例如，我将图片都放在一个figs的文件夹下面，<br><img src="https://img-blog.csdnimg.cn/20210128001342882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>相对路径的代码如下：</p><pre><code class="cpp">\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;    \includegraphics[scale=0.4]&#123;figs/lufei2&#125;\end&#123;document&#125;</code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20210128001842497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>绝对路径</code>：参照上例，只需改一行为</p><pre><code class="cpp">\includegraphics[scale=0.4]&#123;C:/Latex排版/figs/lufei2&#125;</code></pre><h1 id="浮动体"><a href="#浮动体" class="headerlink" title="浮动体"></a>浮动体</h1><p>接下来，让我们引进另一个概念——浮动体，一般情况下我们很少会把图片直接插入到我们的文本当中，而是会给它放置在一个叫做浮动体（float）的东西中。这样图片可以有一些相对位置的变换，不会造成分页困难等问题。</p><p>图片的浮动环境是figure</p><pre><code class="cpp">    \begin&#123;figure&#125;[htbp]        \centering    \includegraphics[scale=0.4]&#123;lufei1&#125;    \caption&#123;Dream of being a pirate king&#125;    \label&#123;fig:1&#125;    \end&#123;figure&#125;</code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20210128003317537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>请忽略哪些英文，是我随便写，放进去的。现在来研究figure里面用到的参数<br><code>[htbp]</code>:控制图片在文档中的位置，按照从左到右的顺序，可以更改为[hptb]等等。</p><pre><code> h(here)    此处 t(top)     页顶 b(bottom)  页底 p(page)    独立一页</code></pre><p>图片为了更好的插入文档呢，因为图片占文档大小的关系，由[htbp]会依次类推至放的进的地方，当然，大多所时候我们需要用的是h（here）,即插入我在文档里规定的位置，如果插不进去，我们需要修改图片的宽高.参照上面对图片大小的设置。</p><p><code>centering</code>：使图片居中<br><code>caption</code>：对图片命名<br><code>label</code>：给图片规定一个标签，方便用 \eqref{}语句进行跳转。<br><img src="https://img-blog.csdnimg.cn/20210128144947737.png" alt="在这里插入图片描述"></p><h1 id="多图并列"><a href="#多图并列" class="headerlink" title="多图并列"></a>多图并列</h1><p>通过前面的引导，我相信大家已经基本掌握图片是如何插入的了，但我们在论文排版时，经常会遇到需要将多个图片放置在一起进行比较，这时就需要实现多张图片并排~<br>接下来，我们讲讲怎么实现图片的并排效果<br>Latex提高了<strong>subfigure</strong>宏包进行多图排版。所以现在我们现在需要多添加一个宏包</p><pre><code>\usepackage&#123;graphicx&#125;\usepackage&#123;subfigure&#125;</code></pre><p>首先我们来实现4个图片在同一行的情况<br>代码如下：</p><pre><code>\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;subfigure&#125;\begin&#123;document&#125;    \begin&#123;figure&#125;[htbp]        \center        \subfigure[lufei-1]&#123;\label&#123;fig:1a&#125;        \includegraphics[width=0.15\linewidth]&#123;lufei1&#125;&#125;        \subfigure[lufei-2]&#123;\label&#123;fig:1b&#125;        \includegraphics[width=0.15\linewidth]&#123;lufei2&#125;&#125;        \subfigure[lufei-3]&#123;\label&#123;fig:1c&#125;        \includegraphics[width=0.15\linewidth]&#123;lufei3&#125;&#125;        \subfigure[lufei-4]&#123;\label&#123;fig:1c&#125;        \includegraphics[width=0.15\linewidth]&#123;lufei4&#125;&#125;            \caption&#123;Dream of being a pirate king&#125;    \label&#123;fig:1&#125;    \end&#123;figure&#125;\end&#123;document&#125;</code></pre><p>效果如下<br><img src="https://img-blog.csdnimg.cn/20210128145558188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>已经实现4张图片的插入了，注意控制图片的宽度，在此，我们设定的图片宽度为：width=0.15\linewidth]  每张图片设定占置文档的0.15倍</p><p>如果我们需要把它变成2行2列的形式。在latex代码中每隔两个subfigure打一个回车键，奇妙的事情就发生了！<br>代码如下：</p><pre><code class="bash">![\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;subfigure&#125;\begin&#123;document&#125;    \begin&#123;figure&#125;[htbp]        \center        \subfigure[lufei-1]&#123;\label&#123;fig:1a&#125;        \includegraphics[width=0.15\linewidth]&#123;lufei1&#125;&#125;        \subfigure[lufei-2]&#123;\label&#123;fig:1b&#125;        \includegraphics[width=0.15\linewidth]&#123;lufei2&#125;&#125;            \subfigure[lufei-3]&#123;\label&#123;fig:1c&#125;        \includegraphics[width=0.15\linewidth]&#123;lufei3&#125;&#125;        \subfigure[lufei-4]&#123;\label&#123;fig:1c&#125;        \includegraphics[width=0.15\linewidth]&#123;lufei4&#125;&#125;            \caption&#123;Dream of being a pirate king&#125;    \label&#123;fig:1&#125;    \end&#123;figure&#125;\end&#123;document&#125;]</code></pre><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210128152325912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215bmFtZWlzZ3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>好啦~ 看到这里，我相信大家都已经基本掌握怎么在Latex使用图片了。</p>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
